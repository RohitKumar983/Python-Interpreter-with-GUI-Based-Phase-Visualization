Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     statements -> statement
Rule 3     statements -> statements statement
Rule 4     statement -> print_stmt
Rule 5     statement -> assign_stmt
Rule 6     statement -> if_stmt
Rule 7     statement -> while_stmt
Rule 8     statement -> for_stmt
Rule 9     statement -> function_def
Rule 10    statement -> return_stmt
Rule 11    statement -> break_stmt
Rule 12    statement -> continue_stmt
Rule 13    statement -> try_except_stmt
Rule 14    statement -> NEWLINE
Rule 15    print_stmt -> PRINT LPAREN expr RPAREN
Rule 16    print_stmt -> PRINT expr
Rule 17    assign_stmt -> IDENTIFIER EQUALS expr
Rule 18    assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET EQUALS expr
Rule 19    if_stmt -> IF expr COLON statements
Rule 20    if_stmt -> IF expr COLON statements ELSE COLON statements
Rule 21    while_stmt -> WHILE expr COLON statements
Rule 22    for_stmt -> FOR IDENTIFIER IN expr COLON statements
Rule 23    function_def -> DEF IDENTIFIER LPAREN param_list RPAREN COLON statements
Rule 24    param_list -> IDENTIFIER
Rule 25    param_list -> param_list COMMA IDENTIFIER
Rule 26    param_list -> empty
Rule 27    return_stmt -> RETURN expr
Rule 28    return_stmt -> RETURN
Rule 29    break_stmt -> BREAK
Rule 30    continue_stmt -> CONTINUE
Rule 31    try_except_stmt -> TRY COLON statements EXCEPT COLON statements
Rule 32    expr -> term
Rule 33    expr -> expr PLUS term
Rule 34    expr -> expr MINUS term
Rule 35    expr -> expr TIMES term
Rule 36    expr -> expr DIVIDE term
Rule 37    expr -> expr MODULO term
Rule 38    expr -> expr GT term
Rule 39    expr -> expr LT term
Rule 40    expr -> expr GE term
Rule 41    expr -> expr LE term
Rule 42    expr -> expr EQ term
Rule 43    expr -> expr NE term
Rule 44    expr -> expr AND term
Rule 45    expr -> expr OR term
Rule 46    term -> factor
Rule 47    term -> NOT term
Rule 48    term -> MINUS term
Rule 49    factor -> NUMBER
Rule 50    factor -> STRING
Rule 51    factor -> TRUE
Rule 52    factor -> FALSE
Rule 53    factor -> IDENTIFIER
Rule 54    factor -> list_expr
Rule 55    factor -> function_call
Rule 56    factor -> string_method
Rule 57    factor -> len_function
Rule 58    factor -> range_call
Rule 59    factor -> LPAREN expr RPAREN
Rule 60    list_expr -> LBRACKET expr_list RBRACKET
Rule 61    list_expr -> IDENTIFIER LBRACKET expr RBRACKET
Rule 62    expr_list -> expr
Rule 63    expr_list -> expr_list COMMA expr
Rule 64    expr_list -> empty
Rule 65    function_call -> IDENTIFIER LPAREN expr_list RPAREN
Rule 66    function_call -> IDENTIFIER LPAREN RPAREN
Rule 67    string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
Rule 68    string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
Rule 69    len_function -> LEN LPAREN expr RPAREN
Rule 70    range_call -> RANGE LPAREN expr_list RPAREN
Rule 71    range_call -> RANGE LPAREN RPAREN
Rule 72    expression -> IDENTIFIER LPAREN arg_list RPAREN
Rule 73    arg_list -> expression
Rule 74    arg_list -> arg_list COMMA expression
Rule 75    arg_list -> empty
Rule 76    empty -> <empty>

Terminals, with rules where they appear

AND                  : 44
BREAK                : 29
COLON                : 19 20 20 21 22 23 31 31
COMMA                : 25 63 74
CONTINUE             : 30
DEF                  : 23
DIVIDE               : 36
DOT                  : 67 68
ELSE                 : 20
EQ                   : 42
EQUALS               : 17 18
EXCEPT               : 31
FALSE                : 52
FOR                  : 22
GE                   : 40
GT                   : 38
IDENTIFIER           : 17 18 22 23 24 25 53 61 65 66 67 67 68 68 72
IF                   : 19 20
IN                   : 22
LBRACKET             : 18 60 61
LE                   : 41
LEN                  : 69
LPAREN               : 15 23 59 65 66 67 68 69 70 71 72
LT                   : 39
MINUS                : 34 48
MODULO               : 37
NE                   : 43
NEWLINE              : 14
NOT                  : 47
NUMBER               : 49
OR                   : 45
PLUS                 : 33
PRINT                : 15 16
RANGE                : 70 71
RBRACKET             : 18 60 61
RETURN               : 27 28
RPAREN               : 15 23 59 65 66 67 68 69 70 71 72
STRING               : 50
TIMES                : 35
TRUE                 : 51
TRY                  : 31
WHILE                : 21
error                : 

Nonterminals, with rules where they appear

arg_list             : 72 74
assign_stmt          : 5
break_stmt           : 11
continue_stmt        : 12
empty                : 26 64 75
expr                 : 15 16 17 18 18 19 20 21 22 27 33 34 35 36 37 38 39 40 41 42 43 44 45 59 61 62 63 69
expr_list            : 60 63 65 67 70
expression           : 73 74
factor               : 46
for_stmt             : 8
function_call        : 55
function_def         : 9
if_stmt              : 6
len_function         : 57
list_expr            : 54
param_list           : 23 25
print_stmt           : 4
program              : 0
range_call           : 58
return_stmt          : 10
statement            : 2 3
statements           : 1 3 19 20 20 21 22 23 31 31
string_method        : 56
term                 : 32 33 34 35 36 37 38 39 40 41 42 43 44 45 47 48
try_except_stmt      : 13
while_stmt           : 7

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . print_stmt
    (5) statement -> . assign_stmt
    (6) statement -> . if_stmt
    (7) statement -> . while_stmt
    (8) statement -> . for_stmt
    (9) statement -> . function_def
    (10) statement -> . return_stmt
    (11) statement -> . break_stmt
    (12) statement -> . continue_stmt
    (13) statement -> . try_except_stmt
    (14) statement -> . NEWLINE
    (15) print_stmt -> . PRINT LPAREN expr RPAREN
    (16) print_stmt -> . PRINT expr
    (17) assign_stmt -> . IDENTIFIER EQUALS expr
    (18) assign_stmt -> . IDENTIFIER LBRACKET expr RBRACKET EQUALS expr
    (19) if_stmt -> . IF expr COLON statements
    (20) if_stmt -> . IF expr COLON statements ELSE COLON statements
    (21) while_stmt -> . WHILE expr COLON statements
    (22) for_stmt -> . FOR IDENTIFIER IN expr COLON statements
    (23) function_def -> . DEF IDENTIFIER LPAREN param_list RPAREN COLON statements
    (27) return_stmt -> . RETURN expr
    (28) return_stmt -> . RETURN
    (29) break_stmt -> . BREAK
    (30) continue_stmt -> . CONTINUE
    (31) try_except_stmt -> . TRY COLON statements EXCEPT COLON statements

    NEWLINE         shift and go to state 14
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19
    DEF             shift and go to state 20
    RETURN          shift and go to state 21
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    TRY             shift and go to state 24

    program                        shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    if_stmt                        shift and go to state 6
    while_stmt                     shift and go to state 7
    for_stmt                       shift and go to state 8
    function_def                   shift and go to state 9
    return_stmt                    shift and go to state 10
    break_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    try_except_stmt                shift and go to state 13

state 1

    (0) S' -> program .



state 2

    (1) program -> statements .
    (3) statements -> statements . statement
    (4) statement -> . print_stmt
    (5) statement -> . assign_stmt
    (6) statement -> . if_stmt
    (7) statement -> . while_stmt
    (8) statement -> . for_stmt
    (9) statement -> . function_def
    (10) statement -> . return_stmt
    (11) statement -> . break_stmt
    (12) statement -> . continue_stmt
    (13) statement -> . try_except_stmt
    (14) statement -> . NEWLINE
    (15) print_stmt -> . PRINT LPAREN expr RPAREN
    (16) print_stmt -> . PRINT expr
    (17) assign_stmt -> . IDENTIFIER EQUALS expr
    (18) assign_stmt -> . IDENTIFIER LBRACKET expr RBRACKET EQUALS expr
    (19) if_stmt -> . IF expr COLON statements
    (20) if_stmt -> . IF expr COLON statements ELSE COLON statements
    (21) while_stmt -> . WHILE expr COLON statements
    (22) for_stmt -> . FOR IDENTIFIER IN expr COLON statements
    (23) function_def -> . DEF IDENTIFIER LPAREN param_list RPAREN COLON statements
    (27) return_stmt -> . RETURN expr
    (28) return_stmt -> . RETURN
    (29) break_stmt -> . BREAK
    (30) continue_stmt -> . CONTINUE
    (31) try_except_stmt -> . TRY COLON statements EXCEPT COLON statements

    $end            reduce using rule 1 (program -> statements .)
    NEWLINE         shift and go to state 14
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19
    DEF             shift and go to state 20
    RETURN          shift and go to state 21
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    TRY             shift and go to state 24

    statement                      shift and go to state 25
    print_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    if_stmt                        shift and go to state 6
    while_stmt                     shift and go to state 7
    for_stmt                       shift and go to state 8
    function_def                   shift and go to state 9
    return_stmt                    shift and go to state 10
    break_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    try_except_stmt                shift and go to state 13

state 3

    (2) statements -> statement .

    NEWLINE         reduce using rule 2 (statements -> statement .)
    PRINT           reduce using rule 2 (statements -> statement .)
    IDENTIFIER      reduce using rule 2 (statements -> statement .)
    IF              reduce using rule 2 (statements -> statement .)
    WHILE           reduce using rule 2 (statements -> statement .)
    FOR             reduce using rule 2 (statements -> statement .)
    DEF             reduce using rule 2 (statements -> statement .)
    RETURN          reduce using rule 2 (statements -> statement .)
    BREAK           reduce using rule 2 (statements -> statement .)
    CONTINUE        reduce using rule 2 (statements -> statement .)
    TRY             reduce using rule 2 (statements -> statement .)
    $end            reduce using rule 2 (statements -> statement .)
    EXCEPT          reduce using rule 2 (statements -> statement .)
    ELSE            reduce using rule 2 (statements -> statement .)


state 4

    (4) statement -> print_stmt .

    NEWLINE         reduce using rule 4 (statement -> print_stmt .)
    PRINT           reduce using rule 4 (statement -> print_stmt .)
    IDENTIFIER      reduce using rule 4 (statement -> print_stmt .)
    IF              reduce using rule 4 (statement -> print_stmt .)
    WHILE           reduce using rule 4 (statement -> print_stmt .)
    FOR             reduce using rule 4 (statement -> print_stmt .)
    DEF             reduce using rule 4 (statement -> print_stmt .)
    RETURN          reduce using rule 4 (statement -> print_stmt .)
    BREAK           reduce using rule 4 (statement -> print_stmt .)
    CONTINUE        reduce using rule 4 (statement -> print_stmt .)
    TRY             reduce using rule 4 (statement -> print_stmt .)
    $end            reduce using rule 4 (statement -> print_stmt .)
    EXCEPT          reduce using rule 4 (statement -> print_stmt .)
    ELSE            reduce using rule 4 (statement -> print_stmt .)


state 5

    (5) statement -> assign_stmt .

    NEWLINE         reduce using rule 5 (statement -> assign_stmt .)
    PRINT           reduce using rule 5 (statement -> assign_stmt .)
    IDENTIFIER      reduce using rule 5 (statement -> assign_stmt .)
    IF              reduce using rule 5 (statement -> assign_stmt .)
    WHILE           reduce using rule 5 (statement -> assign_stmt .)
    FOR             reduce using rule 5 (statement -> assign_stmt .)
    DEF             reduce using rule 5 (statement -> assign_stmt .)
    RETURN          reduce using rule 5 (statement -> assign_stmt .)
    BREAK           reduce using rule 5 (statement -> assign_stmt .)
    CONTINUE        reduce using rule 5 (statement -> assign_stmt .)
    TRY             reduce using rule 5 (statement -> assign_stmt .)
    $end            reduce using rule 5 (statement -> assign_stmt .)
    EXCEPT          reduce using rule 5 (statement -> assign_stmt .)
    ELSE            reduce using rule 5 (statement -> assign_stmt .)


state 6

    (6) statement -> if_stmt .

    NEWLINE         reduce using rule 6 (statement -> if_stmt .)
    PRINT           reduce using rule 6 (statement -> if_stmt .)
    IDENTIFIER      reduce using rule 6 (statement -> if_stmt .)
    IF              reduce using rule 6 (statement -> if_stmt .)
    WHILE           reduce using rule 6 (statement -> if_stmt .)
    FOR             reduce using rule 6 (statement -> if_stmt .)
    DEF             reduce using rule 6 (statement -> if_stmt .)
    RETURN          reduce using rule 6 (statement -> if_stmt .)
    BREAK           reduce using rule 6 (statement -> if_stmt .)
    CONTINUE        reduce using rule 6 (statement -> if_stmt .)
    TRY             reduce using rule 6 (statement -> if_stmt .)
    $end            reduce using rule 6 (statement -> if_stmt .)
    EXCEPT          reduce using rule 6 (statement -> if_stmt .)
    ELSE            reduce using rule 6 (statement -> if_stmt .)


state 7

    (7) statement -> while_stmt .

    NEWLINE         reduce using rule 7 (statement -> while_stmt .)
    PRINT           reduce using rule 7 (statement -> while_stmt .)
    IDENTIFIER      reduce using rule 7 (statement -> while_stmt .)
    IF              reduce using rule 7 (statement -> while_stmt .)
    WHILE           reduce using rule 7 (statement -> while_stmt .)
    FOR             reduce using rule 7 (statement -> while_stmt .)
    DEF             reduce using rule 7 (statement -> while_stmt .)
    RETURN          reduce using rule 7 (statement -> while_stmt .)
    BREAK           reduce using rule 7 (statement -> while_stmt .)
    CONTINUE        reduce using rule 7 (statement -> while_stmt .)
    TRY             reduce using rule 7 (statement -> while_stmt .)
    $end            reduce using rule 7 (statement -> while_stmt .)
    EXCEPT          reduce using rule 7 (statement -> while_stmt .)
    ELSE            reduce using rule 7 (statement -> while_stmt .)


state 8

    (8) statement -> for_stmt .

    NEWLINE         reduce using rule 8 (statement -> for_stmt .)
    PRINT           reduce using rule 8 (statement -> for_stmt .)
    IDENTIFIER      reduce using rule 8 (statement -> for_stmt .)
    IF              reduce using rule 8 (statement -> for_stmt .)
    WHILE           reduce using rule 8 (statement -> for_stmt .)
    FOR             reduce using rule 8 (statement -> for_stmt .)
    DEF             reduce using rule 8 (statement -> for_stmt .)
    RETURN          reduce using rule 8 (statement -> for_stmt .)
    BREAK           reduce using rule 8 (statement -> for_stmt .)
    CONTINUE        reduce using rule 8 (statement -> for_stmt .)
    TRY             reduce using rule 8 (statement -> for_stmt .)
    $end            reduce using rule 8 (statement -> for_stmt .)
    EXCEPT          reduce using rule 8 (statement -> for_stmt .)
    ELSE            reduce using rule 8 (statement -> for_stmt .)


state 9

    (9) statement -> function_def .

    NEWLINE         reduce using rule 9 (statement -> function_def .)
    PRINT           reduce using rule 9 (statement -> function_def .)
    IDENTIFIER      reduce using rule 9 (statement -> function_def .)
    IF              reduce using rule 9 (statement -> function_def .)
    WHILE           reduce using rule 9 (statement -> function_def .)
    FOR             reduce using rule 9 (statement -> function_def .)
    DEF             reduce using rule 9 (statement -> function_def .)
    RETURN          reduce using rule 9 (statement -> function_def .)
    BREAK           reduce using rule 9 (statement -> function_def .)
    CONTINUE        reduce using rule 9 (statement -> function_def .)
    TRY             reduce using rule 9 (statement -> function_def .)
    $end            reduce using rule 9 (statement -> function_def .)
    EXCEPT          reduce using rule 9 (statement -> function_def .)
    ELSE            reduce using rule 9 (statement -> function_def .)


state 10

    (10) statement -> return_stmt .

    NEWLINE         reduce using rule 10 (statement -> return_stmt .)
    PRINT           reduce using rule 10 (statement -> return_stmt .)
    IDENTIFIER      reduce using rule 10 (statement -> return_stmt .)
    IF              reduce using rule 10 (statement -> return_stmt .)
    WHILE           reduce using rule 10 (statement -> return_stmt .)
    FOR             reduce using rule 10 (statement -> return_stmt .)
    DEF             reduce using rule 10 (statement -> return_stmt .)
    RETURN          reduce using rule 10 (statement -> return_stmt .)
    BREAK           reduce using rule 10 (statement -> return_stmt .)
    CONTINUE        reduce using rule 10 (statement -> return_stmt .)
    TRY             reduce using rule 10 (statement -> return_stmt .)
    $end            reduce using rule 10 (statement -> return_stmt .)
    EXCEPT          reduce using rule 10 (statement -> return_stmt .)
    ELSE            reduce using rule 10 (statement -> return_stmt .)


state 11

    (11) statement -> break_stmt .

    NEWLINE         reduce using rule 11 (statement -> break_stmt .)
    PRINT           reduce using rule 11 (statement -> break_stmt .)
    IDENTIFIER      reduce using rule 11 (statement -> break_stmt .)
    IF              reduce using rule 11 (statement -> break_stmt .)
    WHILE           reduce using rule 11 (statement -> break_stmt .)
    FOR             reduce using rule 11 (statement -> break_stmt .)
    DEF             reduce using rule 11 (statement -> break_stmt .)
    RETURN          reduce using rule 11 (statement -> break_stmt .)
    BREAK           reduce using rule 11 (statement -> break_stmt .)
    CONTINUE        reduce using rule 11 (statement -> break_stmt .)
    TRY             reduce using rule 11 (statement -> break_stmt .)
    $end            reduce using rule 11 (statement -> break_stmt .)
    EXCEPT          reduce using rule 11 (statement -> break_stmt .)
    ELSE            reduce using rule 11 (statement -> break_stmt .)


state 12

    (12) statement -> continue_stmt .

    NEWLINE         reduce using rule 12 (statement -> continue_stmt .)
    PRINT           reduce using rule 12 (statement -> continue_stmt .)
    IDENTIFIER      reduce using rule 12 (statement -> continue_stmt .)
    IF              reduce using rule 12 (statement -> continue_stmt .)
    WHILE           reduce using rule 12 (statement -> continue_stmt .)
    FOR             reduce using rule 12 (statement -> continue_stmt .)
    DEF             reduce using rule 12 (statement -> continue_stmt .)
    RETURN          reduce using rule 12 (statement -> continue_stmt .)
    BREAK           reduce using rule 12 (statement -> continue_stmt .)
    CONTINUE        reduce using rule 12 (statement -> continue_stmt .)
    TRY             reduce using rule 12 (statement -> continue_stmt .)
    $end            reduce using rule 12 (statement -> continue_stmt .)
    EXCEPT          reduce using rule 12 (statement -> continue_stmt .)
    ELSE            reduce using rule 12 (statement -> continue_stmt .)


state 13

    (13) statement -> try_except_stmt .

    NEWLINE         reduce using rule 13 (statement -> try_except_stmt .)
    PRINT           reduce using rule 13 (statement -> try_except_stmt .)
    IDENTIFIER      reduce using rule 13 (statement -> try_except_stmt .)
    IF              reduce using rule 13 (statement -> try_except_stmt .)
    WHILE           reduce using rule 13 (statement -> try_except_stmt .)
    FOR             reduce using rule 13 (statement -> try_except_stmt .)
    DEF             reduce using rule 13 (statement -> try_except_stmt .)
    RETURN          reduce using rule 13 (statement -> try_except_stmt .)
    BREAK           reduce using rule 13 (statement -> try_except_stmt .)
    CONTINUE        reduce using rule 13 (statement -> try_except_stmt .)
    TRY             reduce using rule 13 (statement -> try_except_stmt .)
    $end            reduce using rule 13 (statement -> try_except_stmt .)
    EXCEPT          reduce using rule 13 (statement -> try_except_stmt .)
    ELSE            reduce using rule 13 (statement -> try_except_stmt .)


state 14

    (14) statement -> NEWLINE .

    NEWLINE         reduce using rule 14 (statement -> NEWLINE .)
    PRINT           reduce using rule 14 (statement -> NEWLINE .)
    IDENTIFIER      reduce using rule 14 (statement -> NEWLINE .)
    IF              reduce using rule 14 (statement -> NEWLINE .)
    WHILE           reduce using rule 14 (statement -> NEWLINE .)
    FOR             reduce using rule 14 (statement -> NEWLINE .)
    DEF             reduce using rule 14 (statement -> NEWLINE .)
    RETURN          reduce using rule 14 (statement -> NEWLINE .)
    BREAK           reduce using rule 14 (statement -> NEWLINE .)
    CONTINUE        reduce using rule 14 (statement -> NEWLINE .)
    TRY             reduce using rule 14 (statement -> NEWLINE .)
    $end            reduce using rule 14 (statement -> NEWLINE .)
    EXCEPT          reduce using rule 14 (statement -> NEWLINE .)
    ELSE            reduce using rule 14 (statement -> NEWLINE .)


state 15

    (15) print_stmt -> PRINT . LPAREN expr RPAREN
    (16) print_stmt -> PRINT . expr
    (32) expr -> . term
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . expr TIMES term
    (36) expr -> . expr DIVIDE term
    (37) expr -> . expr MODULO term
    (38) expr -> . expr GT term
    (39) expr -> . expr LT term
    (40) expr -> . expr GE term
    (41) expr -> . expr LE term
    (42) expr -> . expr EQ term
    (43) expr -> . expr NE term
    (44) expr -> . expr AND term
    (45) expr -> . expr OR term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    LPAREN          shift and go to state 26
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    expr                           shift and go to state 27
    term                           shift and go to state 28
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 16

    (17) assign_stmt -> IDENTIFIER . EQUALS expr
    (18) assign_stmt -> IDENTIFIER . LBRACKET expr RBRACKET EQUALS expr

    EQUALS          shift and go to state 45
    LBRACKET        shift and go to state 46


state 17

    (19) if_stmt -> IF . expr COLON statements
    (20) if_stmt -> IF . expr COLON statements ELSE COLON statements
    (32) expr -> . term
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . expr TIMES term
    (36) expr -> . expr DIVIDE term
    (37) expr -> . expr MODULO term
    (38) expr -> . expr GT term
    (39) expr -> . expr LT term
    (40) expr -> . expr GE term
    (41) expr -> . expr LE term
    (42) expr -> . expr EQ term
    (43) expr -> . expr NE term
    (44) expr -> . expr AND term
    (45) expr -> . expr OR term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    expr                           shift and go to state 47
    term                           shift and go to state 28
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 18

    (21) while_stmt -> WHILE . expr COLON statements
    (32) expr -> . term
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . expr TIMES term
    (36) expr -> . expr DIVIDE term
    (37) expr -> . expr MODULO term
    (38) expr -> . expr GT term
    (39) expr -> . expr LT term
    (40) expr -> . expr GE term
    (41) expr -> . expr LE term
    (42) expr -> . expr EQ term
    (43) expr -> . expr NE term
    (44) expr -> . expr AND term
    (45) expr -> . expr OR term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    expr                           shift and go to state 49
    term                           shift and go to state 28
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 19

    (22) for_stmt -> FOR . IDENTIFIER IN expr COLON statements

    IDENTIFIER      shift and go to state 50


state 20

    (23) function_def -> DEF . IDENTIFIER LPAREN param_list RPAREN COLON statements

    IDENTIFIER      shift and go to state 51


state 21

    (27) return_stmt -> RETURN . expr
    (28) return_stmt -> RETURN .
    (32) expr -> . term
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . expr TIMES term
    (36) expr -> . expr DIVIDE term
    (37) expr -> . expr MODULO term
    (38) expr -> . expr GT term
    (39) expr -> . expr LT term
    (40) expr -> . expr GE term
    (41) expr -> . expr LE term
    (42) expr -> . expr EQ term
    (43) expr -> . expr NE term
    (44) expr -> . expr AND term
    (45) expr -> . expr OR term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    NEWLINE         reduce using rule 28 (return_stmt -> RETURN .)
    PRINT           reduce using rule 28 (return_stmt -> RETURN .)
    IF              reduce using rule 28 (return_stmt -> RETURN .)
    WHILE           reduce using rule 28 (return_stmt -> RETURN .)
    FOR             reduce using rule 28 (return_stmt -> RETURN .)
    DEF             reduce using rule 28 (return_stmt -> RETURN .)
    RETURN          reduce using rule 28 (return_stmt -> RETURN .)
    BREAK           reduce using rule 28 (return_stmt -> RETURN .)
    CONTINUE        reduce using rule 28 (return_stmt -> RETURN .)
    TRY             reduce using rule 28 (return_stmt -> RETURN .)
    $end            reduce using rule 28 (return_stmt -> RETURN .)
    EXCEPT          reduce using rule 28 (return_stmt -> RETURN .)
    ELSE            reduce using rule 28 (return_stmt -> RETURN .)
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

  ! IDENTIFIER      [ reduce using rule 28 (return_stmt -> RETURN .) ]

    expr                           shift and go to state 52
    term                           shift and go to state 28
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 22

    (29) break_stmt -> BREAK .

    NEWLINE         reduce using rule 29 (break_stmt -> BREAK .)
    PRINT           reduce using rule 29 (break_stmt -> BREAK .)
    IDENTIFIER      reduce using rule 29 (break_stmt -> BREAK .)
    IF              reduce using rule 29 (break_stmt -> BREAK .)
    WHILE           reduce using rule 29 (break_stmt -> BREAK .)
    FOR             reduce using rule 29 (break_stmt -> BREAK .)
    DEF             reduce using rule 29 (break_stmt -> BREAK .)
    RETURN          reduce using rule 29 (break_stmt -> BREAK .)
    BREAK           reduce using rule 29 (break_stmt -> BREAK .)
    CONTINUE        reduce using rule 29 (break_stmt -> BREAK .)
    TRY             reduce using rule 29 (break_stmt -> BREAK .)
    $end            reduce using rule 29 (break_stmt -> BREAK .)
    EXCEPT          reduce using rule 29 (break_stmt -> BREAK .)
    ELSE            reduce using rule 29 (break_stmt -> BREAK .)


state 23

    (30) continue_stmt -> CONTINUE .

    NEWLINE         reduce using rule 30 (continue_stmt -> CONTINUE .)
    PRINT           reduce using rule 30 (continue_stmt -> CONTINUE .)
    IDENTIFIER      reduce using rule 30 (continue_stmt -> CONTINUE .)
    IF              reduce using rule 30 (continue_stmt -> CONTINUE .)
    WHILE           reduce using rule 30 (continue_stmt -> CONTINUE .)
    FOR             reduce using rule 30 (continue_stmt -> CONTINUE .)
    DEF             reduce using rule 30 (continue_stmt -> CONTINUE .)
    RETURN          reduce using rule 30 (continue_stmt -> CONTINUE .)
    BREAK           reduce using rule 30 (continue_stmt -> CONTINUE .)
    CONTINUE        reduce using rule 30 (continue_stmt -> CONTINUE .)
    TRY             reduce using rule 30 (continue_stmt -> CONTINUE .)
    $end            reduce using rule 30 (continue_stmt -> CONTINUE .)
    EXCEPT          reduce using rule 30 (continue_stmt -> CONTINUE .)
    ELSE            reduce using rule 30 (continue_stmt -> CONTINUE .)


state 24

    (31) try_except_stmt -> TRY . COLON statements EXCEPT COLON statements

    COLON           shift and go to state 53


state 25

    (3) statements -> statements statement .

    NEWLINE         reduce using rule 3 (statements -> statements statement .)
    PRINT           reduce using rule 3 (statements -> statements statement .)
    IDENTIFIER      reduce using rule 3 (statements -> statements statement .)
    IF              reduce using rule 3 (statements -> statements statement .)
    WHILE           reduce using rule 3 (statements -> statements statement .)
    FOR             reduce using rule 3 (statements -> statements statement .)
    DEF             reduce using rule 3 (statements -> statements statement .)
    RETURN          reduce using rule 3 (statements -> statements statement .)
    BREAK           reduce using rule 3 (statements -> statements statement .)
    CONTINUE        reduce using rule 3 (statements -> statements statement .)
    TRY             reduce using rule 3 (statements -> statements statement .)
    $end            reduce using rule 3 (statements -> statements statement .)
    EXCEPT          reduce using rule 3 (statements -> statements statement .)
    ELSE            reduce using rule 3 (statements -> statements statement .)


state 26

    (15) print_stmt -> PRINT LPAREN . expr RPAREN
    (59) factor -> LPAREN . expr RPAREN
    (32) expr -> . term
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . expr TIMES term
    (36) expr -> . expr DIVIDE term
    (37) expr -> . expr MODULO term
    (38) expr -> . expr GT term
    (39) expr -> . expr LT term
    (40) expr -> . expr GE term
    (41) expr -> . expr LE term
    (42) expr -> . expr EQ term
    (43) expr -> . expr NE term
    (44) expr -> . expr AND term
    (45) expr -> . expr OR term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    expr                           shift and go to state 54
    term                           shift and go to state 28
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 27

    (16) print_stmt -> PRINT expr .
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term
    (35) expr -> expr . TIMES term
    (36) expr -> expr . DIVIDE term
    (37) expr -> expr . MODULO term
    (38) expr -> expr . GT term
    (39) expr -> expr . LT term
    (40) expr -> expr . GE term
    (41) expr -> expr . LE term
    (42) expr -> expr . EQ term
    (43) expr -> expr . NE term
    (44) expr -> expr . AND term
    (45) expr -> expr . OR term

    NEWLINE         reduce using rule 16 (print_stmt -> PRINT expr .)
    PRINT           reduce using rule 16 (print_stmt -> PRINT expr .)
    IDENTIFIER      reduce using rule 16 (print_stmt -> PRINT expr .)
    IF              reduce using rule 16 (print_stmt -> PRINT expr .)
    WHILE           reduce using rule 16 (print_stmt -> PRINT expr .)
    FOR             reduce using rule 16 (print_stmt -> PRINT expr .)
    DEF             reduce using rule 16 (print_stmt -> PRINT expr .)
    RETURN          reduce using rule 16 (print_stmt -> PRINT expr .)
    BREAK           reduce using rule 16 (print_stmt -> PRINT expr .)
    CONTINUE        reduce using rule 16 (print_stmt -> PRINT expr .)
    TRY             reduce using rule 16 (print_stmt -> PRINT expr .)
    $end            reduce using rule 16 (print_stmt -> PRINT expr .)
    EXCEPT          reduce using rule 16 (print_stmt -> PRINT expr .)
    ELSE            reduce using rule 16 (print_stmt -> PRINT expr .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    GE              shift and go to state 62
    LE              shift and go to state 63
    EQ              shift and go to state 64
    NE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 28

    (32) expr -> term .

    PLUS            reduce using rule 32 (expr -> term .)
    MINUS           reduce using rule 32 (expr -> term .)
    TIMES           reduce using rule 32 (expr -> term .)
    DIVIDE          reduce using rule 32 (expr -> term .)
    MODULO          reduce using rule 32 (expr -> term .)
    GT              reduce using rule 32 (expr -> term .)
    LT              reduce using rule 32 (expr -> term .)
    GE              reduce using rule 32 (expr -> term .)
    LE              reduce using rule 32 (expr -> term .)
    EQ              reduce using rule 32 (expr -> term .)
    NE              reduce using rule 32 (expr -> term .)
    AND             reduce using rule 32 (expr -> term .)
    OR              reduce using rule 32 (expr -> term .)
    NEWLINE         reduce using rule 32 (expr -> term .)
    PRINT           reduce using rule 32 (expr -> term .)
    IDENTIFIER      reduce using rule 32 (expr -> term .)
    IF              reduce using rule 32 (expr -> term .)
    WHILE           reduce using rule 32 (expr -> term .)
    FOR             reduce using rule 32 (expr -> term .)
    DEF             reduce using rule 32 (expr -> term .)
    RETURN          reduce using rule 32 (expr -> term .)
    BREAK           reduce using rule 32 (expr -> term .)
    CONTINUE        reduce using rule 32 (expr -> term .)
    TRY             reduce using rule 32 (expr -> term .)
    $end            reduce using rule 32 (expr -> term .)
    EXCEPT          reduce using rule 32 (expr -> term .)
    ELSE            reduce using rule 32 (expr -> term .)
    COLON           reduce using rule 32 (expr -> term .)
    RPAREN          reduce using rule 32 (expr -> term .)
    RBRACKET        reduce using rule 32 (expr -> term .)
    COMMA           reduce using rule 32 (expr -> term .)


state 29

    (48) term -> MINUS . term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    term                           shift and go to state 68
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 30

    (46) term -> factor .

    PLUS            reduce using rule 46 (term -> factor .)
    MINUS           reduce using rule 46 (term -> factor .)
    TIMES           reduce using rule 46 (term -> factor .)
    DIVIDE          reduce using rule 46 (term -> factor .)
    MODULO          reduce using rule 46 (term -> factor .)
    GT              reduce using rule 46 (term -> factor .)
    LT              reduce using rule 46 (term -> factor .)
    GE              reduce using rule 46 (term -> factor .)
    LE              reduce using rule 46 (term -> factor .)
    EQ              reduce using rule 46 (term -> factor .)
    NE              reduce using rule 46 (term -> factor .)
    AND             reduce using rule 46 (term -> factor .)
    OR              reduce using rule 46 (term -> factor .)
    NEWLINE         reduce using rule 46 (term -> factor .)
    PRINT           reduce using rule 46 (term -> factor .)
    IDENTIFIER      reduce using rule 46 (term -> factor .)
    IF              reduce using rule 46 (term -> factor .)
    WHILE           reduce using rule 46 (term -> factor .)
    FOR             reduce using rule 46 (term -> factor .)
    DEF             reduce using rule 46 (term -> factor .)
    RETURN          reduce using rule 46 (term -> factor .)
    BREAK           reduce using rule 46 (term -> factor .)
    CONTINUE        reduce using rule 46 (term -> factor .)
    TRY             reduce using rule 46 (term -> factor .)
    $end            reduce using rule 46 (term -> factor .)
    EXCEPT          reduce using rule 46 (term -> factor .)
    ELSE            reduce using rule 46 (term -> factor .)
    COLON           reduce using rule 46 (term -> factor .)
    RPAREN          reduce using rule 46 (term -> factor .)
    RBRACKET        reduce using rule 46 (term -> factor .)
    COMMA           reduce using rule 46 (term -> factor .)


state 31

    (47) term -> NOT . term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    term                           shift and go to state 69
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 32

    (49) factor -> NUMBER .

    PLUS            reduce using rule 49 (factor -> NUMBER .)
    MINUS           reduce using rule 49 (factor -> NUMBER .)
    TIMES           reduce using rule 49 (factor -> NUMBER .)
    DIVIDE          reduce using rule 49 (factor -> NUMBER .)
    MODULO          reduce using rule 49 (factor -> NUMBER .)
    GT              reduce using rule 49 (factor -> NUMBER .)
    LT              reduce using rule 49 (factor -> NUMBER .)
    GE              reduce using rule 49 (factor -> NUMBER .)
    LE              reduce using rule 49 (factor -> NUMBER .)
    EQ              reduce using rule 49 (factor -> NUMBER .)
    NE              reduce using rule 49 (factor -> NUMBER .)
    AND             reduce using rule 49 (factor -> NUMBER .)
    OR              reduce using rule 49 (factor -> NUMBER .)
    NEWLINE         reduce using rule 49 (factor -> NUMBER .)
    PRINT           reduce using rule 49 (factor -> NUMBER .)
    IDENTIFIER      reduce using rule 49 (factor -> NUMBER .)
    IF              reduce using rule 49 (factor -> NUMBER .)
    WHILE           reduce using rule 49 (factor -> NUMBER .)
    FOR             reduce using rule 49 (factor -> NUMBER .)
    DEF             reduce using rule 49 (factor -> NUMBER .)
    RETURN          reduce using rule 49 (factor -> NUMBER .)
    BREAK           reduce using rule 49 (factor -> NUMBER .)
    CONTINUE        reduce using rule 49 (factor -> NUMBER .)
    TRY             reduce using rule 49 (factor -> NUMBER .)
    $end            reduce using rule 49 (factor -> NUMBER .)
    EXCEPT          reduce using rule 49 (factor -> NUMBER .)
    ELSE            reduce using rule 49 (factor -> NUMBER .)
    COLON           reduce using rule 49 (factor -> NUMBER .)
    RPAREN          reduce using rule 49 (factor -> NUMBER .)
    RBRACKET        reduce using rule 49 (factor -> NUMBER .)
    COMMA           reduce using rule 49 (factor -> NUMBER .)


state 33

    (50) factor -> STRING .

    PLUS            reduce using rule 50 (factor -> STRING .)
    MINUS           reduce using rule 50 (factor -> STRING .)
    TIMES           reduce using rule 50 (factor -> STRING .)
    DIVIDE          reduce using rule 50 (factor -> STRING .)
    MODULO          reduce using rule 50 (factor -> STRING .)
    GT              reduce using rule 50 (factor -> STRING .)
    LT              reduce using rule 50 (factor -> STRING .)
    GE              reduce using rule 50 (factor -> STRING .)
    LE              reduce using rule 50 (factor -> STRING .)
    EQ              reduce using rule 50 (factor -> STRING .)
    NE              reduce using rule 50 (factor -> STRING .)
    AND             reduce using rule 50 (factor -> STRING .)
    OR              reduce using rule 50 (factor -> STRING .)
    NEWLINE         reduce using rule 50 (factor -> STRING .)
    PRINT           reduce using rule 50 (factor -> STRING .)
    IDENTIFIER      reduce using rule 50 (factor -> STRING .)
    IF              reduce using rule 50 (factor -> STRING .)
    WHILE           reduce using rule 50 (factor -> STRING .)
    FOR             reduce using rule 50 (factor -> STRING .)
    DEF             reduce using rule 50 (factor -> STRING .)
    RETURN          reduce using rule 50 (factor -> STRING .)
    BREAK           reduce using rule 50 (factor -> STRING .)
    CONTINUE        reduce using rule 50 (factor -> STRING .)
    TRY             reduce using rule 50 (factor -> STRING .)
    $end            reduce using rule 50 (factor -> STRING .)
    EXCEPT          reduce using rule 50 (factor -> STRING .)
    ELSE            reduce using rule 50 (factor -> STRING .)
    COLON           reduce using rule 50 (factor -> STRING .)
    RPAREN          reduce using rule 50 (factor -> STRING .)
    RBRACKET        reduce using rule 50 (factor -> STRING .)
    COMMA           reduce using rule 50 (factor -> STRING .)


state 34

    (51) factor -> TRUE .

    PLUS            reduce using rule 51 (factor -> TRUE .)
    MINUS           reduce using rule 51 (factor -> TRUE .)
    TIMES           reduce using rule 51 (factor -> TRUE .)
    DIVIDE          reduce using rule 51 (factor -> TRUE .)
    MODULO          reduce using rule 51 (factor -> TRUE .)
    GT              reduce using rule 51 (factor -> TRUE .)
    LT              reduce using rule 51 (factor -> TRUE .)
    GE              reduce using rule 51 (factor -> TRUE .)
    LE              reduce using rule 51 (factor -> TRUE .)
    EQ              reduce using rule 51 (factor -> TRUE .)
    NE              reduce using rule 51 (factor -> TRUE .)
    AND             reduce using rule 51 (factor -> TRUE .)
    OR              reduce using rule 51 (factor -> TRUE .)
    NEWLINE         reduce using rule 51 (factor -> TRUE .)
    PRINT           reduce using rule 51 (factor -> TRUE .)
    IDENTIFIER      reduce using rule 51 (factor -> TRUE .)
    IF              reduce using rule 51 (factor -> TRUE .)
    WHILE           reduce using rule 51 (factor -> TRUE .)
    FOR             reduce using rule 51 (factor -> TRUE .)
    DEF             reduce using rule 51 (factor -> TRUE .)
    RETURN          reduce using rule 51 (factor -> TRUE .)
    BREAK           reduce using rule 51 (factor -> TRUE .)
    CONTINUE        reduce using rule 51 (factor -> TRUE .)
    TRY             reduce using rule 51 (factor -> TRUE .)
    $end            reduce using rule 51 (factor -> TRUE .)
    EXCEPT          reduce using rule 51 (factor -> TRUE .)
    ELSE            reduce using rule 51 (factor -> TRUE .)
    COLON           reduce using rule 51 (factor -> TRUE .)
    RPAREN          reduce using rule 51 (factor -> TRUE .)
    RBRACKET        reduce using rule 51 (factor -> TRUE .)
    COMMA           reduce using rule 51 (factor -> TRUE .)


state 35

    (52) factor -> FALSE .

    PLUS            reduce using rule 52 (factor -> FALSE .)
    MINUS           reduce using rule 52 (factor -> FALSE .)
    TIMES           reduce using rule 52 (factor -> FALSE .)
    DIVIDE          reduce using rule 52 (factor -> FALSE .)
    MODULO          reduce using rule 52 (factor -> FALSE .)
    GT              reduce using rule 52 (factor -> FALSE .)
    LT              reduce using rule 52 (factor -> FALSE .)
    GE              reduce using rule 52 (factor -> FALSE .)
    LE              reduce using rule 52 (factor -> FALSE .)
    EQ              reduce using rule 52 (factor -> FALSE .)
    NE              reduce using rule 52 (factor -> FALSE .)
    AND             reduce using rule 52 (factor -> FALSE .)
    OR              reduce using rule 52 (factor -> FALSE .)
    NEWLINE         reduce using rule 52 (factor -> FALSE .)
    PRINT           reduce using rule 52 (factor -> FALSE .)
    IDENTIFIER      reduce using rule 52 (factor -> FALSE .)
    IF              reduce using rule 52 (factor -> FALSE .)
    WHILE           reduce using rule 52 (factor -> FALSE .)
    FOR             reduce using rule 52 (factor -> FALSE .)
    DEF             reduce using rule 52 (factor -> FALSE .)
    RETURN          reduce using rule 52 (factor -> FALSE .)
    BREAK           reduce using rule 52 (factor -> FALSE .)
    CONTINUE        reduce using rule 52 (factor -> FALSE .)
    TRY             reduce using rule 52 (factor -> FALSE .)
    $end            reduce using rule 52 (factor -> FALSE .)
    EXCEPT          reduce using rule 52 (factor -> FALSE .)
    ELSE            reduce using rule 52 (factor -> FALSE .)
    COLON           reduce using rule 52 (factor -> FALSE .)
    RPAREN          reduce using rule 52 (factor -> FALSE .)
    RBRACKET        reduce using rule 52 (factor -> FALSE .)
    COMMA           reduce using rule 52 (factor -> FALSE .)


state 36

    (53) factor -> IDENTIFIER .
    (61) list_expr -> IDENTIFIER . LBRACKET expr RBRACKET
    (65) function_call -> IDENTIFIER . LPAREN expr_list RPAREN
    (66) function_call -> IDENTIFIER . LPAREN RPAREN
    (67) string_method -> IDENTIFIER . DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> IDENTIFIER . DOT IDENTIFIER LPAREN RPAREN

    PLUS            reduce using rule 53 (factor -> IDENTIFIER .)
    MINUS           reduce using rule 53 (factor -> IDENTIFIER .)
    TIMES           reduce using rule 53 (factor -> IDENTIFIER .)
    DIVIDE          reduce using rule 53 (factor -> IDENTIFIER .)
    MODULO          reduce using rule 53 (factor -> IDENTIFIER .)
    GT              reduce using rule 53 (factor -> IDENTIFIER .)
    LT              reduce using rule 53 (factor -> IDENTIFIER .)
    GE              reduce using rule 53 (factor -> IDENTIFIER .)
    LE              reduce using rule 53 (factor -> IDENTIFIER .)
    EQ              reduce using rule 53 (factor -> IDENTIFIER .)
    NE              reduce using rule 53 (factor -> IDENTIFIER .)
    AND             reduce using rule 53 (factor -> IDENTIFIER .)
    OR              reduce using rule 53 (factor -> IDENTIFIER .)
    NEWLINE         reduce using rule 53 (factor -> IDENTIFIER .)
    PRINT           reduce using rule 53 (factor -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 53 (factor -> IDENTIFIER .)
    IF              reduce using rule 53 (factor -> IDENTIFIER .)
    WHILE           reduce using rule 53 (factor -> IDENTIFIER .)
    FOR             reduce using rule 53 (factor -> IDENTIFIER .)
    DEF             reduce using rule 53 (factor -> IDENTIFIER .)
    RETURN          reduce using rule 53 (factor -> IDENTIFIER .)
    BREAK           reduce using rule 53 (factor -> IDENTIFIER .)
    CONTINUE        reduce using rule 53 (factor -> IDENTIFIER .)
    TRY             reduce using rule 53 (factor -> IDENTIFIER .)
    $end            reduce using rule 53 (factor -> IDENTIFIER .)
    EXCEPT          reduce using rule 53 (factor -> IDENTIFIER .)
    ELSE            reduce using rule 53 (factor -> IDENTIFIER .)
    COLON           reduce using rule 53 (factor -> IDENTIFIER .)
    RPAREN          reduce using rule 53 (factor -> IDENTIFIER .)
    RBRACKET        reduce using rule 53 (factor -> IDENTIFIER .)
    COMMA           reduce using rule 53 (factor -> IDENTIFIER .)
    LBRACKET        shift and go to state 70
    LPAREN          shift and go to state 71
    DOT             shift and go to state 72


state 37

    (54) factor -> list_expr .

    PLUS            reduce using rule 54 (factor -> list_expr .)
    MINUS           reduce using rule 54 (factor -> list_expr .)
    TIMES           reduce using rule 54 (factor -> list_expr .)
    DIVIDE          reduce using rule 54 (factor -> list_expr .)
    MODULO          reduce using rule 54 (factor -> list_expr .)
    GT              reduce using rule 54 (factor -> list_expr .)
    LT              reduce using rule 54 (factor -> list_expr .)
    GE              reduce using rule 54 (factor -> list_expr .)
    LE              reduce using rule 54 (factor -> list_expr .)
    EQ              reduce using rule 54 (factor -> list_expr .)
    NE              reduce using rule 54 (factor -> list_expr .)
    AND             reduce using rule 54 (factor -> list_expr .)
    OR              reduce using rule 54 (factor -> list_expr .)
    NEWLINE         reduce using rule 54 (factor -> list_expr .)
    PRINT           reduce using rule 54 (factor -> list_expr .)
    IDENTIFIER      reduce using rule 54 (factor -> list_expr .)
    IF              reduce using rule 54 (factor -> list_expr .)
    WHILE           reduce using rule 54 (factor -> list_expr .)
    FOR             reduce using rule 54 (factor -> list_expr .)
    DEF             reduce using rule 54 (factor -> list_expr .)
    RETURN          reduce using rule 54 (factor -> list_expr .)
    BREAK           reduce using rule 54 (factor -> list_expr .)
    CONTINUE        reduce using rule 54 (factor -> list_expr .)
    TRY             reduce using rule 54 (factor -> list_expr .)
    $end            reduce using rule 54 (factor -> list_expr .)
    EXCEPT          reduce using rule 54 (factor -> list_expr .)
    ELSE            reduce using rule 54 (factor -> list_expr .)
    COLON           reduce using rule 54 (factor -> list_expr .)
    RPAREN          reduce using rule 54 (factor -> list_expr .)
    RBRACKET        reduce using rule 54 (factor -> list_expr .)
    COMMA           reduce using rule 54 (factor -> list_expr .)


state 38

    (55) factor -> function_call .

    PLUS            reduce using rule 55 (factor -> function_call .)
    MINUS           reduce using rule 55 (factor -> function_call .)
    TIMES           reduce using rule 55 (factor -> function_call .)
    DIVIDE          reduce using rule 55 (factor -> function_call .)
    MODULO          reduce using rule 55 (factor -> function_call .)
    GT              reduce using rule 55 (factor -> function_call .)
    LT              reduce using rule 55 (factor -> function_call .)
    GE              reduce using rule 55 (factor -> function_call .)
    LE              reduce using rule 55 (factor -> function_call .)
    EQ              reduce using rule 55 (factor -> function_call .)
    NE              reduce using rule 55 (factor -> function_call .)
    AND             reduce using rule 55 (factor -> function_call .)
    OR              reduce using rule 55 (factor -> function_call .)
    NEWLINE         reduce using rule 55 (factor -> function_call .)
    PRINT           reduce using rule 55 (factor -> function_call .)
    IDENTIFIER      reduce using rule 55 (factor -> function_call .)
    IF              reduce using rule 55 (factor -> function_call .)
    WHILE           reduce using rule 55 (factor -> function_call .)
    FOR             reduce using rule 55 (factor -> function_call .)
    DEF             reduce using rule 55 (factor -> function_call .)
    RETURN          reduce using rule 55 (factor -> function_call .)
    BREAK           reduce using rule 55 (factor -> function_call .)
    CONTINUE        reduce using rule 55 (factor -> function_call .)
    TRY             reduce using rule 55 (factor -> function_call .)
    $end            reduce using rule 55 (factor -> function_call .)
    EXCEPT          reduce using rule 55 (factor -> function_call .)
    ELSE            reduce using rule 55 (factor -> function_call .)
    COLON           reduce using rule 55 (factor -> function_call .)
    RPAREN          reduce using rule 55 (factor -> function_call .)
    RBRACKET        reduce using rule 55 (factor -> function_call .)
    COMMA           reduce using rule 55 (factor -> function_call .)


state 39

    (56) factor -> string_method .

    PLUS            reduce using rule 56 (factor -> string_method .)
    MINUS           reduce using rule 56 (factor -> string_method .)
    TIMES           reduce using rule 56 (factor -> string_method .)
    DIVIDE          reduce using rule 56 (factor -> string_method .)
    MODULO          reduce using rule 56 (factor -> string_method .)
    GT              reduce using rule 56 (factor -> string_method .)
    LT              reduce using rule 56 (factor -> string_method .)
    GE              reduce using rule 56 (factor -> string_method .)
    LE              reduce using rule 56 (factor -> string_method .)
    EQ              reduce using rule 56 (factor -> string_method .)
    NE              reduce using rule 56 (factor -> string_method .)
    AND             reduce using rule 56 (factor -> string_method .)
    OR              reduce using rule 56 (factor -> string_method .)
    NEWLINE         reduce using rule 56 (factor -> string_method .)
    PRINT           reduce using rule 56 (factor -> string_method .)
    IDENTIFIER      reduce using rule 56 (factor -> string_method .)
    IF              reduce using rule 56 (factor -> string_method .)
    WHILE           reduce using rule 56 (factor -> string_method .)
    FOR             reduce using rule 56 (factor -> string_method .)
    DEF             reduce using rule 56 (factor -> string_method .)
    RETURN          reduce using rule 56 (factor -> string_method .)
    BREAK           reduce using rule 56 (factor -> string_method .)
    CONTINUE        reduce using rule 56 (factor -> string_method .)
    TRY             reduce using rule 56 (factor -> string_method .)
    $end            reduce using rule 56 (factor -> string_method .)
    EXCEPT          reduce using rule 56 (factor -> string_method .)
    ELSE            reduce using rule 56 (factor -> string_method .)
    COLON           reduce using rule 56 (factor -> string_method .)
    RPAREN          reduce using rule 56 (factor -> string_method .)
    RBRACKET        reduce using rule 56 (factor -> string_method .)
    COMMA           reduce using rule 56 (factor -> string_method .)


state 40

    (57) factor -> len_function .

    PLUS            reduce using rule 57 (factor -> len_function .)
    MINUS           reduce using rule 57 (factor -> len_function .)
    TIMES           reduce using rule 57 (factor -> len_function .)
    DIVIDE          reduce using rule 57 (factor -> len_function .)
    MODULO          reduce using rule 57 (factor -> len_function .)
    GT              reduce using rule 57 (factor -> len_function .)
    LT              reduce using rule 57 (factor -> len_function .)
    GE              reduce using rule 57 (factor -> len_function .)
    LE              reduce using rule 57 (factor -> len_function .)
    EQ              reduce using rule 57 (factor -> len_function .)
    NE              reduce using rule 57 (factor -> len_function .)
    AND             reduce using rule 57 (factor -> len_function .)
    OR              reduce using rule 57 (factor -> len_function .)
    NEWLINE         reduce using rule 57 (factor -> len_function .)
    PRINT           reduce using rule 57 (factor -> len_function .)
    IDENTIFIER      reduce using rule 57 (factor -> len_function .)
    IF              reduce using rule 57 (factor -> len_function .)
    WHILE           reduce using rule 57 (factor -> len_function .)
    FOR             reduce using rule 57 (factor -> len_function .)
    DEF             reduce using rule 57 (factor -> len_function .)
    RETURN          reduce using rule 57 (factor -> len_function .)
    BREAK           reduce using rule 57 (factor -> len_function .)
    CONTINUE        reduce using rule 57 (factor -> len_function .)
    TRY             reduce using rule 57 (factor -> len_function .)
    $end            reduce using rule 57 (factor -> len_function .)
    EXCEPT          reduce using rule 57 (factor -> len_function .)
    ELSE            reduce using rule 57 (factor -> len_function .)
    COLON           reduce using rule 57 (factor -> len_function .)
    RPAREN          reduce using rule 57 (factor -> len_function .)
    RBRACKET        reduce using rule 57 (factor -> len_function .)
    COMMA           reduce using rule 57 (factor -> len_function .)


state 41

    (58) factor -> range_call .

    PLUS            reduce using rule 58 (factor -> range_call .)
    MINUS           reduce using rule 58 (factor -> range_call .)
    TIMES           reduce using rule 58 (factor -> range_call .)
    DIVIDE          reduce using rule 58 (factor -> range_call .)
    MODULO          reduce using rule 58 (factor -> range_call .)
    GT              reduce using rule 58 (factor -> range_call .)
    LT              reduce using rule 58 (factor -> range_call .)
    GE              reduce using rule 58 (factor -> range_call .)
    LE              reduce using rule 58 (factor -> range_call .)
    EQ              reduce using rule 58 (factor -> range_call .)
    NE              reduce using rule 58 (factor -> range_call .)
    AND             reduce using rule 58 (factor -> range_call .)
    OR              reduce using rule 58 (factor -> range_call .)
    NEWLINE         reduce using rule 58 (factor -> range_call .)
    PRINT           reduce using rule 58 (factor -> range_call .)
    IDENTIFIER      reduce using rule 58 (factor -> range_call .)
    IF              reduce using rule 58 (factor -> range_call .)
    WHILE           reduce using rule 58 (factor -> range_call .)
    FOR             reduce using rule 58 (factor -> range_call .)
    DEF             reduce using rule 58 (factor -> range_call .)
    RETURN          reduce using rule 58 (factor -> range_call .)
    BREAK           reduce using rule 58 (factor -> range_call .)
    CONTINUE        reduce using rule 58 (factor -> range_call .)
    TRY             reduce using rule 58 (factor -> range_call .)
    $end            reduce using rule 58 (factor -> range_call .)
    EXCEPT          reduce using rule 58 (factor -> range_call .)
    ELSE            reduce using rule 58 (factor -> range_call .)
    COLON           reduce using rule 58 (factor -> range_call .)
    RPAREN          reduce using rule 58 (factor -> range_call .)
    RBRACKET        reduce using rule 58 (factor -> range_call .)
    COMMA           reduce using rule 58 (factor -> range_call .)


state 42

    (60) list_expr -> LBRACKET . expr_list RBRACKET
    (62) expr_list -> . expr
    (63) expr_list -> . expr_list COMMA expr
    (64) expr_list -> . empty
    (32) expr -> . term
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . expr TIMES term
    (36) expr -> . expr DIVIDE term
    (37) expr -> . expr MODULO term
    (38) expr -> . expr GT term
    (39) expr -> . expr LT term
    (40) expr -> . expr GE term
    (41) expr -> . expr LE term
    (42) expr -> . expr EQ term
    (43) expr -> . expr NE term
    (44) expr -> . expr AND term
    (45) expr -> . expr OR term
    (76) empty -> .
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    RBRACKET        reduce using rule 76 (empty -> .)
    COMMA           reduce using rule 76 (empty -> .)
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    expr_list                      shift and go to state 73
    expr                           shift and go to state 74
    empty                          shift and go to state 75
    term                           shift and go to state 28
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 43

    (69) len_function -> LEN . LPAREN expr RPAREN

    LPAREN          shift and go to state 76


state 44

    (70) range_call -> RANGE . LPAREN expr_list RPAREN
    (71) range_call -> RANGE . LPAREN RPAREN

    LPAREN          shift and go to state 77


state 45

    (17) assign_stmt -> IDENTIFIER EQUALS . expr
    (32) expr -> . term
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . expr TIMES term
    (36) expr -> . expr DIVIDE term
    (37) expr -> . expr MODULO term
    (38) expr -> . expr GT term
    (39) expr -> . expr LT term
    (40) expr -> . expr GE term
    (41) expr -> . expr LE term
    (42) expr -> . expr EQ term
    (43) expr -> . expr NE term
    (44) expr -> . expr AND term
    (45) expr -> . expr OR term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    expr                           shift and go to state 78
    term                           shift and go to state 28
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 46

    (18) assign_stmt -> IDENTIFIER LBRACKET . expr RBRACKET EQUALS expr
    (32) expr -> . term
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . expr TIMES term
    (36) expr -> . expr DIVIDE term
    (37) expr -> . expr MODULO term
    (38) expr -> . expr GT term
    (39) expr -> . expr LT term
    (40) expr -> . expr GE term
    (41) expr -> . expr LE term
    (42) expr -> . expr EQ term
    (43) expr -> . expr NE term
    (44) expr -> . expr AND term
    (45) expr -> . expr OR term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    expr                           shift and go to state 79
    term                           shift and go to state 28
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 47

    (19) if_stmt -> IF expr . COLON statements
    (20) if_stmt -> IF expr . COLON statements ELSE COLON statements
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term
    (35) expr -> expr . TIMES term
    (36) expr -> expr . DIVIDE term
    (37) expr -> expr . MODULO term
    (38) expr -> expr . GT term
    (39) expr -> expr . LT term
    (40) expr -> expr . GE term
    (41) expr -> expr . LE term
    (42) expr -> expr . EQ term
    (43) expr -> expr . NE term
    (44) expr -> expr . AND term
    (45) expr -> expr . OR term

    COLON           shift and go to state 80
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    GE              shift and go to state 62
    LE              shift and go to state 63
    EQ              shift and go to state 64
    NE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 48

    (59) factor -> LPAREN . expr RPAREN
    (32) expr -> . term
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . expr TIMES term
    (36) expr -> . expr DIVIDE term
    (37) expr -> . expr MODULO term
    (38) expr -> . expr GT term
    (39) expr -> . expr LT term
    (40) expr -> . expr GE term
    (41) expr -> . expr LE term
    (42) expr -> . expr EQ term
    (43) expr -> . expr NE term
    (44) expr -> . expr AND term
    (45) expr -> . expr OR term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    expr                           shift and go to state 81
    term                           shift and go to state 28
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 49

    (21) while_stmt -> WHILE expr . COLON statements
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term
    (35) expr -> expr . TIMES term
    (36) expr -> expr . DIVIDE term
    (37) expr -> expr . MODULO term
    (38) expr -> expr . GT term
    (39) expr -> expr . LT term
    (40) expr -> expr . GE term
    (41) expr -> expr . LE term
    (42) expr -> expr . EQ term
    (43) expr -> expr . NE term
    (44) expr -> expr . AND term
    (45) expr -> expr . OR term

    COLON           shift and go to state 82
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    GE              shift and go to state 62
    LE              shift and go to state 63
    EQ              shift and go to state 64
    NE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 50

    (22) for_stmt -> FOR IDENTIFIER . IN expr COLON statements

    IN              shift and go to state 83


state 51

    (23) function_def -> DEF IDENTIFIER . LPAREN param_list RPAREN COLON statements

    LPAREN          shift and go to state 84


state 52

    (27) return_stmt -> RETURN expr .
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term
    (35) expr -> expr . TIMES term
    (36) expr -> expr . DIVIDE term
    (37) expr -> expr . MODULO term
    (38) expr -> expr . GT term
    (39) expr -> expr . LT term
    (40) expr -> expr . GE term
    (41) expr -> expr . LE term
    (42) expr -> expr . EQ term
    (43) expr -> expr . NE term
    (44) expr -> expr . AND term
    (45) expr -> expr . OR term

    NEWLINE         reduce using rule 27 (return_stmt -> RETURN expr .)
    PRINT           reduce using rule 27 (return_stmt -> RETURN expr .)
    IDENTIFIER      reduce using rule 27 (return_stmt -> RETURN expr .)
    IF              reduce using rule 27 (return_stmt -> RETURN expr .)
    WHILE           reduce using rule 27 (return_stmt -> RETURN expr .)
    FOR             reduce using rule 27 (return_stmt -> RETURN expr .)
    DEF             reduce using rule 27 (return_stmt -> RETURN expr .)
    RETURN          reduce using rule 27 (return_stmt -> RETURN expr .)
    BREAK           reduce using rule 27 (return_stmt -> RETURN expr .)
    CONTINUE        reduce using rule 27 (return_stmt -> RETURN expr .)
    TRY             reduce using rule 27 (return_stmt -> RETURN expr .)
    $end            reduce using rule 27 (return_stmt -> RETURN expr .)
    EXCEPT          reduce using rule 27 (return_stmt -> RETURN expr .)
    ELSE            reduce using rule 27 (return_stmt -> RETURN expr .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    GE              shift and go to state 62
    LE              shift and go to state 63
    EQ              shift and go to state 64
    NE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 53

    (31) try_except_stmt -> TRY COLON . statements EXCEPT COLON statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . print_stmt
    (5) statement -> . assign_stmt
    (6) statement -> . if_stmt
    (7) statement -> . while_stmt
    (8) statement -> . for_stmt
    (9) statement -> . function_def
    (10) statement -> . return_stmt
    (11) statement -> . break_stmt
    (12) statement -> . continue_stmt
    (13) statement -> . try_except_stmt
    (14) statement -> . NEWLINE
    (15) print_stmt -> . PRINT LPAREN expr RPAREN
    (16) print_stmt -> . PRINT expr
    (17) assign_stmt -> . IDENTIFIER EQUALS expr
    (18) assign_stmt -> . IDENTIFIER LBRACKET expr RBRACKET EQUALS expr
    (19) if_stmt -> . IF expr COLON statements
    (20) if_stmt -> . IF expr COLON statements ELSE COLON statements
    (21) while_stmt -> . WHILE expr COLON statements
    (22) for_stmt -> . FOR IDENTIFIER IN expr COLON statements
    (23) function_def -> . DEF IDENTIFIER LPAREN param_list RPAREN COLON statements
    (27) return_stmt -> . RETURN expr
    (28) return_stmt -> . RETURN
    (29) break_stmt -> . BREAK
    (30) continue_stmt -> . CONTINUE
    (31) try_except_stmt -> . TRY COLON statements EXCEPT COLON statements

    NEWLINE         shift and go to state 14
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19
    DEF             shift and go to state 20
    RETURN          shift and go to state 21
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    TRY             shift and go to state 24

    statements                     shift and go to state 85
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    if_stmt                        shift and go to state 6
    while_stmt                     shift and go to state 7
    for_stmt                       shift and go to state 8
    function_def                   shift and go to state 9
    return_stmt                    shift and go to state 10
    break_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    try_except_stmt                shift and go to state 13

state 54

    (15) print_stmt -> PRINT LPAREN expr . RPAREN
    (59) factor -> LPAREN expr . RPAREN
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term
    (35) expr -> expr . TIMES term
    (36) expr -> expr . DIVIDE term
    (37) expr -> expr . MODULO term
    (38) expr -> expr . GT term
    (39) expr -> expr . LT term
    (40) expr -> expr . GE term
    (41) expr -> expr . LE term
    (42) expr -> expr . EQ term
    (43) expr -> expr . NE term
    (44) expr -> expr . AND term
    (45) expr -> expr . OR term

    RPAREN          shift and go to state 86
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    GE              shift and go to state 62
    LE              shift and go to state 63
    EQ              shift and go to state 64
    NE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 55

    (33) expr -> expr PLUS . term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    term                           shift and go to state 87
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 56

    (34) expr -> expr MINUS . term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    term                           shift and go to state 88
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 57

    (35) expr -> expr TIMES . term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    term                           shift and go to state 89
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 58

    (36) expr -> expr DIVIDE . term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    term                           shift and go to state 90
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 59

    (37) expr -> expr MODULO . term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    term                           shift and go to state 91
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 60

    (38) expr -> expr GT . term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    term                           shift and go to state 92
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 61

    (39) expr -> expr LT . term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    term                           shift and go to state 93
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 62

    (40) expr -> expr GE . term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    term                           shift and go to state 94
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 63

    (41) expr -> expr LE . term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    term                           shift and go to state 95
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 64

    (42) expr -> expr EQ . term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    term                           shift and go to state 96
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 65

    (43) expr -> expr NE . term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    term                           shift and go to state 97
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 66

    (44) expr -> expr AND . term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    term                           shift and go to state 98
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 67

    (45) expr -> expr OR . term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    term                           shift and go to state 99
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 68

    (48) term -> MINUS term .

    PLUS            reduce using rule 48 (term -> MINUS term .)
    MINUS           reduce using rule 48 (term -> MINUS term .)
    TIMES           reduce using rule 48 (term -> MINUS term .)
    DIVIDE          reduce using rule 48 (term -> MINUS term .)
    MODULO          reduce using rule 48 (term -> MINUS term .)
    GT              reduce using rule 48 (term -> MINUS term .)
    LT              reduce using rule 48 (term -> MINUS term .)
    GE              reduce using rule 48 (term -> MINUS term .)
    LE              reduce using rule 48 (term -> MINUS term .)
    EQ              reduce using rule 48 (term -> MINUS term .)
    NE              reduce using rule 48 (term -> MINUS term .)
    AND             reduce using rule 48 (term -> MINUS term .)
    OR              reduce using rule 48 (term -> MINUS term .)
    NEWLINE         reduce using rule 48 (term -> MINUS term .)
    PRINT           reduce using rule 48 (term -> MINUS term .)
    IDENTIFIER      reduce using rule 48 (term -> MINUS term .)
    IF              reduce using rule 48 (term -> MINUS term .)
    WHILE           reduce using rule 48 (term -> MINUS term .)
    FOR             reduce using rule 48 (term -> MINUS term .)
    DEF             reduce using rule 48 (term -> MINUS term .)
    RETURN          reduce using rule 48 (term -> MINUS term .)
    BREAK           reduce using rule 48 (term -> MINUS term .)
    CONTINUE        reduce using rule 48 (term -> MINUS term .)
    TRY             reduce using rule 48 (term -> MINUS term .)
    $end            reduce using rule 48 (term -> MINUS term .)
    EXCEPT          reduce using rule 48 (term -> MINUS term .)
    ELSE            reduce using rule 48 (term -> MINUS term .)
    COLON           reduce using rule 48 (term -> MINUS term .)
    RPAREN          reduce using rule 48 (term -> MINUS term .)
    RBRACKET        reduce using rule 48 (term -> MINUS term .)
    COMMA           reduce using rule 48 (term -> MINUS term .)


state 69

    (47) term -> NOT term .

    PLUS            reduce using rule 47 (term -> NOT term .)
    MINUS           reduce using rule 47 (term -> NOT term .)
    TIMES           reduce using rule 47 (term -> NOT term .)
    DIVIDE          reduce using rule 47 (term -> NOT term .)
    MODULO          reduce using rule 47 (term -> NOT term .)
    GT              reduce using rule 47 (term -> NOT term .)
    LT              reduce using rule 47 (term -> NOT term .)
    GE              reduce using rule 47 (term -> NOT term .)
    LE              reduce using rule 47 (term -> NOT term .)
    EQ              reduce using rule 47 (term -> NOT term .)
    NE              reduce using rule 47 (term -> NOT term .)
    AND             reduce using rule 47 (term -> NOT term .)
    OR              reduce using rule 47 (term -> NOT term .)
    NEWLINE         reduce using rule 47 (term -> NOT term .)
    PRINT           reduce using rule 47 (term -> NOT term .)
    IDENTIFIER      reduce using rule 47 (term -> NOT term .)
    IF              reduce using rule 47 (term -> NOT term .)
    WHILE           reduce using rule 47 (term -> NOT term .)
    FOR             reduce using rule 47 (term -> NOT term .)
    DEF             reduce using rule 47 (term -> NOT term .)
    RETURN          reduce using rule 47 (term -> NOT term .)
    BREAK           reduce using rule 47 (term -> NOT term .)
    CONTINUE        reduce using rule 47 (term -> NOT term .)
    TRY             reduce using rule 47 (term -> NOT term .)
    $end            reduce using rule 47 (term -> NOT term .)
    EXCEPT          reduce using rule 47 (term -> NOT term .)
    ELSE            reduce using rule 47 (term -> NOT term .)
    COLON           reduce using rule 47 (term -> NOT term .)
    RPAREN          reduce using rule 47 (term -> NOT term .)
    RBRACKET        reduce using rule 47 (term -> NOT term .)
    COMMA           reduce using rule 47 (term -> NOT term .)


state 70

    (61) list_expr -> IDENTIFIER LBRACKET . expr RBRACKET
    (32) expr -> . term
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . expr TIMES term
    (36) expr -> . expr DIVIDE term
    (37) expr -> . expr MODULO term
    (38) expr -> . expr GT term
    (39) expr -> . expr LT term
    (40) expr -> . expr GE term
    (41) expr -> . expr LE term
    (42) expr -> . expr EQ term
    (43) expr -> . expr NE term
    (44) expr -> . expr AND term
    (45) expr -> . expr OR term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    expr                           shift and go to state 100
    term                           shift and go to state 28
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 71

    (65) function_call -> IDENTIFIER LPAREN . expr_list RPAREN
    (66) function_call -> IDENTIFIER LPAREN . RPAREN
    (62) expr_list -> . expr
    (63) expr_list -> . expr_list COMMA expr
    (64) expr_list -> . empty
    (32) expr -> . term
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . expr TIMES term
    (36) expr -> . expr DIVIDE term
    (37) expr -> . expr MODULO term
    (38) expr -> . expr GT term
    (39) expr -> . expr LT term
    (40) expr -> . expr GE term
    (41) expr -> . expr LE term
    (42) expr -> . expr EQ term
    (43) expr -> . expr NE term
    (44) expr -> . expr AND term
    (45) expr -> . expr OR term
    (76) empty -> .
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 102
    COMMA           reduce using rule 76 (empty -> .)
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

  ! RPAREN          [ reduce using rule 76 (empty -> .) ]

    expr_list                      shift and go to state 101
    expr                           shift and go to state 74
    empty                          shift and go to state 75
    term                           shift and go to state 28
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 72

    (67) string_method -> IDENTIFIER DOT . IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> IDENTIFIER DOT . IDENTIFIER LPAREN RPAREN

    IDENTIFIER      shift and go to state 103


state 73

    (60) list_expr -> LBRACKET expr_list . RBRACKET
    (63) expr_list -> expr_list . COMMA expr

    RBRACKET        shift and go to state 104
    COMMA           shift and go to state 105


state 74

    (62) expr_list -> expr .
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term
    (35) expr -> expr . TIMES term
    (36) expr -> expr . DIVIDE term
    (37) expr -> expr . MODULO term
    (38) expr -> expr . GT term
    (39) expr -> expr . LT term
    (40) expr -> expr . GE term
    (41) expr -> expr . LE term
    (42) expr -> expr . EQ term
    (43) expr -> expr . NE term
    (44) expr -> expr . AND term
    (45) expr -> expr . OR term

    RBRACKET        reduce using rule 62 (expr_list -> expr .)
    COMMA           reduce using rule 62 (expr_list -> expr .)
    RPAREN          reduce using rule 62 (expr_list -> expr .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    GE              shift and go to state 62
    LE              shift and go to state 63
    EQ              shift and go to state 64
    NE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 75

    (64) expr_list -> empty .

    RBRACKET        reduce using rule 64 (expr_list -> empty .)
    COMMA           reduce using rule 64 (expr_list -> empty .)
    RPAREN          reduce using rule 64 (expr_list -> empty .)


state 76

    (69) len_function -> LEN LPAREN . expr RPAREN
    (32) expr -> . term
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . expr TIMES term
    (36) expr -> . expr DIVIDE term
    (37) expr -> . expr MODULO term
    (38) expr -> . expr GT term
    (39) expr -> . expr LT term
    (40) expr -> . expr GE term
    (41) expr -> . expr LE term
    (42) expr -> . expr EQ term
    (43) expr -> . expr NE term
    (44) expr -> . expr AND term
    (45) expr -> . expr OR term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    expr                           shift and go to state 106
    term                           shift and go to state 28
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 77

    (70) range_call -> RANGE LPAREN . expr_list RPAREN
    (71) range_call -> RANGE LPAREN . RPAREN
    (62) expr_list -> . expr
    (63) expr_list -> . expr_list COMMA expr
    (64) expr_list -> . empty
    (32) expr -> . term
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . expr TIMES term
    (36) expr -> . expr DIVIDE term
    (37) expr -> . expr MODULO term
    (38) expr -> . expr GT term
    (39) expr -> . expr LT term
    (40) expr -> . expr GE term
    (41) expr -> . expr LE term
    (42) expr -> . expr EQ term
    (43) expr -> . expr NE term
    (44) expr -> . expr AND term
    (45) expr -> . expr OR term
    (76) empty -> .
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 108
    COMMA           reduce using rule 76 (empty -> .)
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

  ! RPAREN          [ reduce using rule 76 (empty -> .) ]

    expr_list                      shift and go to state 107
    expr                           shift and go to state 74
    empty                          shift and go to state 75
    term                           shift and go to state 28
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 78

    (17) assign_stmt -> IDENTIFIER EQUALS expr .
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term
    (35) expr -> expr . TIMES term
    (36) expr -> expr . DIVIDE term
    (37) expr -> expr . MODULO term
    (38) expr -> expr . GT term
    (39) expr -> expr . LT term
    (40) expr -> expr . GE term
    (41) expr -> expr . LE term
    (42) expr -> expr . EQ term
    (43) expr -> expr . NE term
    (44) expr -> expr . AND term
    (45) expr -> expr . OR term

    NEWLINE         reduce using rule 17 (assign_stmt -> IDENTIFIER EQUALS expr .)
    PRINT           reduce using rule 17 (assign_stmt -> IDENTIFIER EQUALS expr .)
    IDENTIFIER      reduce using rule 17 (assign_stmt -> IDENTIFIER EQUALS expr .)
    IF              reduce using rule 17 (assign_stmt -> IDENTIFIER EQUALS expr .)
    WHILE           reduce using rule 17 (assign_stmt -> IDENTIFIER EQUALS expr .)
    FOR             reduce using rule 17 (assign_stmt -> IDENTIFIER EQUALS expr .)
    DEF             reduce using rule 17 (assign_stmt -> IDENTIFIER EQUALS expr .)
    RETURN          reduce using rule 17 (assign_stmt -> IDENTIFIER EQUALS expr .)
    BREAK           reduce using rule 17 (assign_stmt -> IDENTIFIER EQUALS expr .)
    CONTINUE        reduce using rule 17 (assign_stmt -> IDENTIFIER EQUALS expr .)
    TRY             reduce using rule 17 (assign_stmt -> IDENTIFIER EQUALS expr .)
    $end            reduce using rule 17 (assign_stmt -> IDENTIFIER EQUALS expr .)
    EXCEPT          reduce using rule 17 (assign_stmt -> IDENTIFIER EQUALS expr .)
    ELSE            reduce using rule 17 (assign_stmt -> IDENTIFIER EQUALS expr .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    GE              shift and go to state 62
    LE              shift and go to state 63
    EQ              shift and go to state 64
    NE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 79

    (18) assign_stmt -> IDENTIFIER LBRACKET expr . RBRACKET EQUALS expr
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term
    (35) expr -> expr . TIMES term
    (36) expr -> expr . DIVIDE term
    (37) expr -> expr . MODULO term
    (38) expr -> expr . GT term
    (39) expr -> expr . LT term
    (40) expr -> expr . GE term
    (41) expr -> expr . LE term
    (42) expr -> expr . EQ term
    (43) expr -> expr . NE term
    (44) expr -> expr . AND term
    (45) expr -> expr . OR term

    RBRACKET        shift and go to state 109
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    GE              shift and go to state 62
    LE              shift and go to state 63
    EQ              shift and go to state 64
    NE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 80

    (19) if_stmt -> IF expr COLON . statements
    (20) if_stmt -> IF expr COLON . statements ELSE COLON statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . print_stmt
    (5) statement -> . assign_stmt
    (6) statement -> . if_stmt
    (7) statement -> . while_stmt
    (8) statement -> . for_stmt
    (9) statement -> . function_def
    (10) statement -> . return_stmt
    (11) statement -> . break_stmt
    (12) statement -> . continue_stmt
    (13) statement -> . try_except_stmt
    (14) statement -> . NEWLINE
    (15) print_stmt -> . PRINT LPAREN expr RPAREN
    (16) print_stmt -> . PRINT expr
    (17) assign_stmt -> . IDENTIFIER EQUALS expr
    (18) assign_stmt -> . IDENTIFIER LBRACKET expr RBRACKET EQUALS expr
    (19) if_stmt -> . IF expr COLON statements
    (20) if_stmt -> . IF expr COLON statements ELSE COLON statements
    (21) while_stmt -> . WHILE expr COLON statements
    (22) for_stmt -> . FOR IDENTIFIER IN expr COLON statements
    (23) function_def -> . DEF IDENTIFIER LPAREN param_list RPAREN COLON statements
    (27) return_stmt -> . RETURN expr
    (28) return_stmt -> . RETURN
    (29) break_stmt -> . BREAK
    (30) continue_stmt -> . CONTINUE
    (31) try_except_stmt -> . TRY COLON statements EXCEPT COLON statements

    NEWLINE         shift and go to state 14
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19
    DEF             shift and go to state 20
    RETURN          shift and go to state 21
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    TRY             shift and go to state 24

    statements                     shift and go to state 110
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    if_stmt                        shift and go to state 6
    while_stmt                     shift and go to state 7
    for_stmt                       shift and go to state 8
    function_def                   shift and go to state 9
    return_stmt                    shift and go to state 10
    break_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    try_except_stmt                shift and go to state 13

state 81

    (59) factor -> LPAREN expr . RPAREN
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term
    (35) expr -> expr . TIMES term
    (36) expr -> expr . DIVIDE term
    (37) expr -> expr . MODULO term
    (38) expr -> expr . GT term
    (39) expr -> expr . LT term
    (40) expr -> expr . GE term
    (41) expr -> expr . LE term
    (42) expr -> expr . EQ term
    (43) expr -> expr . NE term
    (44) expr -> expr . AND term
    (45) expr -> expr . OR term

    RPAREN          shift and go to state 111
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    GE              shift and go to state 62
    LE              shift and go to state 63
    EQ              shift and go to state 64
    NE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 82

    (21) while_stmt -> WHILE expr COLON . statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . print_stmt
    (5) statement -> . assign_stmt
    (6) statement -> . if_stmt
    (7) statement -> . while_stmt
    (8) statement -> . for_stmt
    (9) statement -> . function_def
    (10) statement -> . return_stmt
    (11) statement -> . break_stmt
    (12) statement -> . continue_stmt
    (13) statement -> . try_except_stmt
    (14) statement -> . NEWLINE
    (15) print_stmt -> . PRINT LPAREN expr RPAREN
    (16) print_stmt -> . PRINT expr
    (17) assign_stmt -> . IDENTIFIER EQUALS expr
    (18) assign_stmt -> . IDENTIFIER LBRACKET expr RBRACKET EQUALS expr
    (19) if_stmt -> . IF expr COLON statements
    (20) if_stmt -> . IF expr COLON statements ELSE COLON statements
    (21) while_stmt -> . WHILE expr COLON statements
    (22) for_stmt -> . FOR IDENTIFIER IN expr COLON statements
    (23) function_def -> . DEF IDENTIFIER LPAREN param_list RPAREN COLON statements
    (27) return_stmt -> . RETURN expr
    (28) return_stmt -> . RETURN
    (29) break_stmt -> . BREAK
    (30) continue_stmt -> . CONTINUE
    (31) try_except_stmt -> . TRY COLON statements EXCEPT COLON statements

    NEWLINE         shift and go to state 14
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19
    DEF             shift and go to state 20
    RETURN          shift and go to state 21
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    TRY             shift and go to state 24

    statements                     shift and go to state 112
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    if_stmt                        shift and go to state 6
    while_stmt                     shift and go to state 7
    for_stmt                       shift and go to state 8
    function_def                   shift and go to state 9
    return_stmt                    shift and go to state 10
    break_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    try_except_stmt                shift and go to state 13

state 83

    (22) for_stmt -> FOR IDENTIFIER IN . expr COLON statements
    (32) expr -> . term
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . expr TIMES term
    (36) expr -> . expr DIVIDE term
    (37) expr -> . expr MODULO term
    (38) expr -> . expr GT term
    (39) expr -> . expr LT term
    (40) expr -> . expr GE term
    (41) expr -> . expr LE term
    (42) expr -> . expr EQ term
    (43) expr -> . expr NE term
    (44) expr -> . expr AND term
    (45) expr -> . expr OR term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    expr                           shift and go to state 113
    term                           shift and go to state 28
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 84

    (23) function_def -> DEF IDENTIFIER LPAREN . param_list RPAREN COLON statements
    (24) param_list -> . IDENTIFIER
    (25) param_list -> . param_list COMMA IDENTIFIER
    (26) param_list -> . empty
    (76) empty -> .

    IDENTIFIER      shift and go to state 114
    RPAREN          reduce using rule 76 (empty -> .)
    COMMA           reduce using rule 76 (empty -> .)

    param_list                     shift and go to state 115
    empty                          shift and go to state 116

state 85

    (31) try_except_stmt -> TRY COLON statements . EXCEPT COLON statements
    (3) statements -> statements . statement
    (4) statement -> . print_stmt
    (5) statement -> . assign_stmt
    (6) statement -> . if_stmt
    (7) statement -> . while_stmt
    (8) statement -> . for_stmt
    (9) statement -> . function_def
    (10) statement -> . return_stmt
    (11) statement -> . break_stmt
    (12) statement -> . continue_stmt
    (13) statement -> . try_except_stmt
    (14) statement -> . NEWLINE
    (15) print_stmt -> . PRINT LPAREN expr RPAREN
    (16) print_stmt -> . PRINT expr
    (17) assign_stmt -> . IDENTIFIER EQUALS expr
    (18) assign_stmt -> . IDENTIFIER LBRACKET expr RBRACKET EQUALS expr
    (19) if_stmt -> . IF expr COLON statements
    (20) if_stmt -> . IF expr COLON statements ELSE COLON statements
    (21) while_stmt -> . WHILE expr COLON statements
    (22) for_stmt -> . FOR IDENTIFIER IN expr COLON statements
    (23) function_def -> . DEF IDENTIFIER LPAREN param_list RPAREN COLON statements
    (27) return_stmt -> . RETURN expr
    (28) return_stmt -> . RETURN
    (29) break_stmt -> . BREAK
    (30) continue_stmt -> . CONTINUE
    (31) try_except_stmt -> . TRY COLON statements EXCEPT COLON statements

    EXCEPT          shift and go to state 117
    NEWLINE         shift and go to state 14
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19
    DEF             shift and go to state 20
    RETURN          shift and go to state 21
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    TRY             shift and go to state 24

    statement                      shift and go to state 25
    print_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    if_stmt                        shift and go to state 6
    while_stmt                     shift and go to state 7
    for_stmt                       shift and go to state 8
    function_def                   shift and go to state 9
    return_stmt                    shift and go to state 10
    break_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    try_except_stmt                shift and go to state 13

state 86

    (15) print_stmt -> PRINT LPAREN expr RPAREN .
    (59) factor -> LPAREN expr RPAREN .

  ! reduce/reduce conflict for NEWLINE resolved using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
  ! reduce/reduce conflict for PRINT resolved using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
  ! reduce/reduce conflict for IF resolved using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
  ! reduce/reduce conflict for WHILE resolved using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
  ! reduce/reduce conflict for FOR resolved using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
  ! reduce/reduce conflict for DEF resolved using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
  ! reduce/reduce conflict for RETURN resolved using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
  ! reduce/reduce conflict for BREAK resolved using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
  ! reduce/reduce conflict for TRY resolved using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
  ! reduce/reduce conflict for $end resolved using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
  ! reduce/reduce conflict for EXCEPT resolved using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
  ! reduce/reduce conflict for ELSE resolved using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
    NEWLINE         reduce using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
    PRINT           reduce using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
    IDENTIFIER      reduce using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
    IF              reduce using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
    WHILE           reduce using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
    FOR             reduce using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
    DEF             reduce using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
    RETURN          reduce using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
    BREAK           reduce using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
    CONTINUE        reduce using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
    TRY             reduce using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
    $end            reduce using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
    EXCEPT          reduce using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
    ELSE            reduce using rule 15 (print_stmt -> PRINT LPAREN expr RPAREN .)
    PLUS            reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    MODULO          reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    GT              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    LT              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    GE              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    LE              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    EQ              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    NE              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    AND             reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    OR              reduce using rule 59 (factor -> LPAREN expr RPAREN .)

  ! NEWLINE         [ reduce using rule 59 (factor -> LPAREN expr RPAREN .) ]
  ! PRINT           [ reduce using rule 59 (factor -> LPAREN expr RPAREN .) ]
  ! IDENTIFIER      [ reduce using rule 59 (factor -> LPAREN expr RPAREN .) ]
  ! IF              [ reduce using rule 59 (factor -> LPAREN expr RPAREN .) ]
  ! WHILE           [ reduce using rule 59 (factor -> LPAREN expr RPAREN .) ]
  ! FOR             [ reduce using rule 59 (factor -> LPAREN expr RPAREN .) ]
  ! DEF             [ reduce using rule 59 (factor -> LPAREN expr RPAREN .) ]
  ! RETURN          [ reduce using rule 59 (factor -> LPAREN expr RPAREN .) ]
  ! BREAK           [ reduce using rule 59 (factor -> LPAREN expr RPAREN .) ]
  ! CONTINUE        [ reduce using rule 59 (factor -> LPAREN expr RPAREN .) ]
  ! TRY             [ reduce using rule 59 (factor -> LPAREN expr RPAREN .) ]
  ! $end            [ reduce using rule 59 (factor -> LPAREN expr RPAREN .) ]
  ! EXCEPT          [ reduce using rule 59 (factor -> LPAREN expr RPAREN .) ]
  ! ELSE            [ reduce using rule 59 (factor -> LPAREN expr RPAREN .) ]


state 87

    (33) expr -> expr PLUS term .

    PLUS            reduce using rule 33 (expr -> expr PLUS term .)
    MINUS           reduce using rule 33 (expr -> expr PLUS term .)
    TIMES           reduce using rule 33 (expr -> expr PLUS term .)
    DIVIDE          reduce using rule 33 (expr -> expr PLUS term .)
    MODULO          reduce using rule 33 (expr -> expr PLUS term .)
    GT              reduce using rule 33 (expr -> expr PLUS term .)
    LT              reduce using rule 33 (expr -> expr PLUS term .)
    GE              reduce using rule 33 (expr -> expr PLUS term .)
    LE              reduce using rule 33 (expr -> expr PLUS term .)
    EQ              reduce using rule 33 (expr -> expr PLUS term .)
    NE              reduce using rule 33 (expr -> expr PLUS term .)
    AND             reduce using rule 33 (expr -> expr PLUS term .)
    OR              reduce using rule 33 (expr -> expr PLUS term .)
    NEWLINE         reduce using rule 33 (expr -> expr PLUS term .)
    PRINT           reduce using rule 33 (expr -> expr PLUS term .)
    IDENTIFIER      reduce using rule 33 (expr -> expr PLUS term .)
    IF              reduce using rule 33 (expr -> expr PLUS term .)
    WHILE           reduce using rule 33 (expr -> expr PLUS term .)
    FOR             reduce using rule 33 (expr -> expr PLUS term .)
    DEF             reduce using rule 33 (expr -> expr PLUS term .)
    RETURN          reduce using rule 33 (expr -> expr PLUS term .)
    BREAK           reduce using rule 33 (expr -> expr PLUS term .)
    CONTINUE        reduce using rule 33 (expr -> expr PLUS term .)
    TRY             reduce using rule 33 (expr -> expr PLUS term .)
    $end            reduce using rule 33 (expr -> expr PLUS term .)
    EXCEPT          reduce using rule 33 (expr -> expr PLUS term .)
    ELSE            reduce using rule 33 (expr -> expr PLUS term .)
    COLON           reduce using rule 33 (expr -> expr PLUS term .)
    RPAREN          reduce using rule 33 (expr -> expr PLUS term .)
    RBRACKET        reduce using rule 33 (expr -> expr PLUS term .)
    COMMA           reduce using rule 33 (expr -> expr PLUS term .)


state 88

    (34) expr -> expr MINUS term .

    PLUS            reduce using rule 34 (expr -> expr MINUS term .)
    MINUS           reduce using rule 34 (expr -> expr MINUS term .)
    TIMES           reduce using rule 34 (expr -> expr MINUS term .)
    DIVIDE          reduce using rule 34 (expr -> expr MINUS term .)
    MODULO          reduce using rule 34 (expr -> expr MINUS term .)
    GT              reduce using rule 34 (expr -> expr MINUS term .)
    LT              reduce using rule 34 (expr -> expr MINUS term .)
    GE              reduce using rule 34 (expr -> expr MINUS term .)
    LE              reduce using rule 34 (expr -> expr MINUS term .)
    EQ              reduce using rule 34 (expr -> expr MINUS term .)
    NE              reduce using rule 34 (expr -> expr MINUS term .)
    AND             reduce using rule 34 (expr -> expr MINUS term .)
    OR              reduce using rule 34 (expr -> expr MINUS term .)
    NEWLINE         reduce using rule 34 (expr -> expr MINUS term .)
    PRINT           reduce using rule 34 (expr -> expr MINUS term .)
    IDENTIFIER      reduce using rule 34 (expr -> expr MINUS term .)
    IF              reduce using rule 34 (expr -> expr MINUS term .)
    WHILE           reduce using rule 34 (expr -> expr MINUS term .)
    FOR             reduce using rule 34 (expr -> expr MINUS term .)
    DEF             reduce using rule 34 (expr -> expr MINUS term .)
    RETURN          reduce using rule 34 (expr -> expr MINUS term .)
    BREAK           reduce using rule 34 (expr -> expr MINUS term .)
    CONTINUE        reduce using rule 34 (expr -> expr MINUS term .)
    TRY             reduce using rule 34 (expr -> expr MINUS term .)
    $end            reduce using rule 34 (expr -> expr MINUS term .)
    EXCEPT          reduce using rule 34 (expr -> expr MINUS term .)
    ELSE            reduce using rule 34 (expr -> expr MINUS term .)
    COLON           reduce using rule 34 (expr -> expr MINUS term .)
    RPAREN          reduce using rule 34 (expr -> expr MINUS term .)
    RBRACKET        reduce using rule 34 (expr -> expr MINUS term .)
    COMMA           reduce using rule 34 (expr -> expr MINUS term .)


state 89

    (35) expr -> expr TIMES term .

    PLUS            reduce using rule 35 (expr -> expr TIMES term .)
    MINUS           reduce using rule 35 (expr -> expr TIMES term .)
    TIMES           reduce using rule 35 (expr -> expr TIMES term .)
    DIVIDE          reduce using rule 35 (expr -> expr TIMES term .)
    MODULO          reduce using rule 35 (expr -> expr TIMES term .)
    GT              reduce using rule 35 (expr -> expr TIMES term .)
    LT              reduce using rule 35 (expr -> expr TIMES term .)
    GE              reduce using rule 35 (expr -> expr TIMES term .)
    LE              reduce using rule 35 (expr -> expr TIMES term .)
    EQ              reduce using rule 35 (expr -> expr TIMES term .)
    NE              reduce using rule 35 (expr -> expr TIMES term .)
    AND             reduce using rule 35 (expr -> expr TIMES term .)
    OR              reduce using rule 35 (expr -> expr TIMES term .)
    NEWLINE         reduce using rule 35 (expr -> expr TIMES term .)
    PRINT           reduce using rule 35 (expr -> expr TIMES term .)
    IDENTIFIER      reduce using rule 35 (expr -> expr TIMES term .)
    IF              reduce using rule 35 (expr -> expr TIMES term .)
    WHILE           reduce using rule 35 (expr -> expr TIMES term .)
    FOR             reduce using rule 35 (expr -> expr TIMES term .)
    DEF             reduce using rule 35 (expr -> expr TIMES term .)
    RETURN          reduce using rule 35 (expr -> expr TIMES term .)
    BREAK           reduce using rule 35 (expr -> expr TIMES term .)
    CONTINUE        reduce using rule 35 (expr -> expr TIMES term .)
    TRY             reduce using rule 35 (expr -> expr TIMES term .)
    $end            reduce using rule 35 (expr -> expr TIMES term .)
    EXCEPT          reduce using rule 35 (expr -> expr TIMES term .)
    ELSE            reduce using rule 35 (expr -> expr TIMES term .)
    COLON           reduce using rule 35 (expr -> expr TIMES term .)
    RPAREN          reduce using rule 35 (expr -> expr TIMES term .)
    RBRACKET        reduce using rule 35 (expr -> expr TIMES term .)
    COMMA           reduce using rule 35 (expr -> expr TIMES term .)


state 90

    (36) expr -> expr DIVIDE term .

    PLUS            reduce using rule 36 (expr -> expr DIVIDE term .)
    MINUS           reduce using rule 36 (expr -> expr DIVIDE term .)
    TIMES           reduce using rule 36 (expr -> expr DIVIDE term .)
    DIVIDE          reduce using rule 36 (expr -> expr DIVIDE term .)
    MODULO          reduce using rule 36 (expr -> expr DIVIDE term .)
    GT              reduce using rule 36 (expr -> expr DIVIDE term .)
    LT              reduce using rule 36 (expr -> expr DIVIDE term .)
    GE              reduce using rule 36 (expr -> expr DIVIDE term .)
    LE              reduce using rule 36 (expr -> expr DIVIDE term .)
    EQ              reduce using rule 36 (expr -> expr DIVIDE term .)
    NE              reduce using rule 36 (expr -> expr DIVIDE term .)
    AND             reduce using rule 36 (expr -> expr DIVIDE term .)
    OR              reduce using rule 36 (expr -> expr DIVIDE term .)
    NEWLINE         reduce using rule 36 (expr -> expr DIVIDE term .)
    PRINT           reduce using rule 36 (expr -> expr DIVIDE term .)
    IDENTIFIER      reduce using rule 36 (expr -> expr DIVIDE term .)
    IF              reduce using rule 36 (expr -> expr DIVIDE term .)
    WHILE           reduce using rule 36 (expr -> expr DIVIDE term .)
    FOR             reduce using rule 36 (expr -> expr DIVIDE term .)
    DEF             reduce using rule 36 (expr -> expr DIVIDE term .)
    RETURN          reduce using rule 36 (expr -> expr DIVIDE term .)
    BREAK           reduce using rule 36 (expr -> expr DIVIDE term .)
    CONTINUE        reduce using rule 36 (expr -> expr DIVIDE term .)
    TRY             reduce using rule 36 (expr -> expr DIVIDE term .)
    $end            reduce using rule 36 (expr -> expr DIVIDE term .)
    EXCEPT          reduce using rule 36 (expr -> expr DIVIDE term .)
    ELSE            reduce using rule 36 (expr -> expr DIVIDE term .)
    COLON           reduce using rule 36 (expr -> expr DIVIDE term .)
    RPAREN          reduce using rule 36 (expr -> expr DIVIDE term .)
    RBRACKET        reduce using rule 36 (expr -> expr DIVIDE term .)
    COMMA           reduce using rule 36 (expr -> expr DIVIDE term .)


state 91

    (37) expr -> expr MODULO term .

    PLUS            reduce using rule 37 (expr -> expr MODULO term .)
    MINUS           reduce using rule 37 (expr -> expr MODULO term .)
    TIMES           reduce using rule 37 (expr -> expr MODULO term .)
    DIVIDE          reduce using rule 37 (expr -> expr MODULO term .)
    MODULO          reduce using rule 37 (expr -> expr MODULO term .)
    GT              reduce using rule 37 (expr -> expr MODULO term .)
    LT              reduce using rule 37 (expr -> expr MODULO term .)
    GE              reduce using rule 37 (expr -> expr MODULO term .)
    LE              reduce using rule 37 (expr -> expr MODULO term .)
    EQ              reduce using rule 37 (expr -> expr MODULO term .)
    NE              reduce using rule 37 (expr -> expr MODULO term .)
    AND             reduce using rule 37 (expr -> expr MODULO term .)
    OR              reduce using rule 37 (expr -> expr MODULO term .)
    NEWLINE         reduce using rule 37 (expr -> expr MODULO term .)
    PRINT           reduce using rule 37 (expr -> expr MODULO term .)
    IDENTIFIER      reduce using rule 37 (expr -> expr MODULO term .)
    IF              reduce using rule 37 (expr -> expr MODULO term .)
    WHILE           reduce using rule 37 (expr -> expr MODULO term .)
    FOR             reduce using rule 37 (expr -> expr MODULO term .)
    DEF             reduce using rule 37 (expr -> expr MODULO term .)
    RETURN          reduce using rule 37 (expr -> expr MODULO term .)
    BREAK           reduce using rule 37 (expr -> expr MODULO term .)
    CONTINUE        reduce using rule 37 (expr -> expr MODULO term .)
    TRY             reduce using rule 37 (expr -> expr MODULO term .)
    $end            reduce using rule 37 (expr -> expr MODULO term .)
    EXCEPT          reduce using rule 37 (expr -> expr MODULO term .)
    ELSE            reduce using rule 37 (expr -> expr MODULO term .)
    COLON           reduce using rule 37 (expr -> expr MODULO term .)
    RPAREN          reduce using rule 37 (expr -> expr MODULO term .)
    RBRACKET        reduce using rule 37 (expr -> expr MODULO term .)
    COMMA           reduce using rule 37 (expr -> expr MODULO term .)


state 92

    (38) expr -> expr GT term .

    PLUS            reduce using rule 38 (expr -> expr GT term .)
    MINUS           reduce using rule 38 (expr -> expr GT term .)
    TIMES           reduce using rule 38 (expr -> expr GT term .)
    DIVIDE          reduce using rule 38 (expr -> expr GT term .)
    MODULO          reduce using rule 38 (expr -> expr GT term .)
    GT              reduce using rule 38 (expr -> expr GT term .)
    LT              reduce using rule 38 (expr -> expr GT term .)
    GE              reduce using rule 38 (expr -> expr GT term .)
    LE              reduce using rule 38 (expr -> expr GT term .)
    EQ              reduce using rule 38 (expr -> expr GT term .)
    NE              reduce using rule 38 (expr -> expr GT term .)
    AND             reduce using rule 38 (expr -> expr GT term .)
    OR              reduce using rule 38 (expr -> expr GT term .)
    NEWLINE         reduce using rule 38 (expr -> expr GT term .)
    PRINT           reduce using rule 38 (expr -> expr GT term .)
    IDENTIFIER      reduce using rule 38 (expr -> expr GT term .)
    IF              reduce using rule 38 (expr -> expr GT term .)
    WHILE           reduce using rule 38 (expr -> expr GT term .)
    FOR             reduce using rule 38 (expr -> expr GT term .)
    DEF             reduce using rule 38 (expr -> expr GT term .)
    RETURN          reduce using rule 38 (expr -> expr GT term .)
    BREAK           reduce using rule 38 (expr -> expr GT term .)
    CONTINUE        reduce using rule 38 (expr -> expr GT term .)
    TRY             reduce using rule 38 (expr -> expr GT term .)
    $end            reduce using rule 38 (expr -> expr GT term .)
    EXCEPT          reduce using rule 38 (expr -> expr GT term .)
    ELSE            reduce using rule 38 (expr -> expr GT term .)
    COLON           reduce using rule 38 (expr -> expr GT term .)
    RPAREN          reduce using rule 38 (expr -> expr GT term .)
    RBRACKET        reduce using rule 38 (expr -> expr GT term .)
    COMMA           reduce using rule 38 (expr -> expr GT term .)


state 93

    (39) expr -> expr LT term .

    PLUS            reduce using rule 39 (expr -> expr LT term .)
    MINUS           reduce using rule 39 (expr -> expr LT term .)
    TIMES           reduce using rule 39 (expr -> expr LT term .)
    DIVIDE          reduce using rule 39 (expr -> expr LT term .)
    MODULO          reduce using rule 39 (expr -> expr LT term .)
    GT              reduce using rule 39 (expr -> expr LT term .)
    LT              reduce using rule 39 (expr -> expr LT term .)
    GE              reduce using rule 39 (expr -> expr LT term .)
    LE              reduce using rule 39 (expr -> expr LT term .)
    EQ              reduce using rule 39 (expr -> expr LT term .)
    NE              reduce using rule 39 (expr -> expr LT term .)
    AND             reduce using rule 39 (expr -> expr LT term .)
    OR              reduce using rule 39 (expr -> expr LT term .)
    NEWLINE         reduce using rule 39 (expr -> expr LT term .)
    PRINT           reduce using rule 39 (expr -> expr LT term .)
    IDENTIFIER      reduce using rule 39 (expr -> expr LT term .)
    IF              reduce using rule 39 (expr -> expr LT term .)
    WHILE           reduce using rule 39 (expr -> expr LT term .)
    FOR             reduce using rule 39 (expr -> expr LT term .)
    DEF             reduce using rule 39 (expr -> expr LT term .)
    RETURN          reduce using rule 39 (expr -> expr LT term .)
    BREAK           reduce using rule 39 (expr -> expr LT term .)
    CONTINUE        reduce using rule 39 (expr -> expr LT term .)
    TRY             reduce using rule 39 (expr -> expr LT term .)
    $end            reduce using rule 39 (expr -> expr LT term .)
    EXCEPT          reduce using rule 39 (expr -> expr LT term .)
    ELSE            reduce using rule 39 (expr -> expr LT term .)
    COLON           reduce using rule 39 (expr -> expr LT term .)
    RPAREN          reduce using rule 39 (expr -> expr LT term .)
    RBRACKET        reduce using rule 39 (expr -> expr LT term .)
    COMMA           reduce using rule 39 (expr -> expr LT term .)


state 94

    (40) expr -> expr GE term .

    PLUS            reduce using rule 40 (expr -> expr GE term .)
    MINUS           reduce using rule 40 (expr -> expr GE term .)
    TIMES           reduce using rule 40 (expr -> expr GE term .)
    DIVIDE          reduce using rule 40 (expr -> expr GE term .)
    MODULO          reduce using rule 40 (expr -> expr GE term .)
    GT              reduce using rule 40 (expr -> expr GE term .)
    LT              reduce using rule 40 (expr -> expr GE term .)
    GE              reduce using rule 40 (expr -> expr GE term .)
    LE              reduce using rule 40 (expr -> expr GE term .)
    EQ              reduce using rule 40 (expr -> expr GE term .)
    NE              reduce using rule 40 (expr -> expr GE term .)
    AND             reduce using rule 40 (expr -> expr GE term .)
    OR              reduce using rule 40 (expr -> expr GE term .)
    NEWLINE         reduce using rule 40 (expr -> expr GE term .)
    PRINT           reduce using rule 40 (expr -> expr GE term .)
    IDENTIFIER      reduce using rule 40 (expr -> expr GE term .)
    IF              reduce using rule 40 (expr -> expr GE term .)
    WHILE           reduce using rule 40 (expr -> expr GE term .)
    FOR             reduce using rule 40 (expr -> expr GE term .)
    DEF             reduce using rule 40 (expr -> expr GE term .)
    RETURN          reduce using rule 40 (expr -> expr GE term .)
    BREAK           reduce using rule 40 (expr -> expr GE term .)
    CONTINUE        reduce using rule 40 (expr -> expr GE term .)
    TRY             reduce using rule 40 (expr -> expr GE term .)
    $end            reduce using rule 40 (expr -> expr GE term .)
    EXCEPT          reduce using rule 40 (expr -> expr GE term .)
    ELSE            reduce using rule 40 (expr -> expr GE term .)
    COLON           reduce using rule 40 (expr -> expr GE term .)
    RPAREN          reduce using rule 40 (expr -> expr GE term .)
    RBRACKET        reduce using rule 40 (expr -> expr GE term .)
    COMMA           reduce using rule 40 (expr -> expr GE term .)


state 95

    (41) expr -> expr LE term .

    PLUS            reduce using rule 41 (expr -> expr LE term .)
    MINUS           reduce using rule 41 (expr -> expr LE term .)
    TIMES           reduce using rule 41 (expr -> expr LE term .)
    DIVIDE          reduce using rule 41 (expr -> expr LE term .)
    MODULO          reduce using rule 41 (expr -> expr LE term .)
    GT              reduce using rule 41 (expr -> expr LE term .)
    LT              reduce using rule 41 (expr -> expr LE term .)
    GE              reduce using rule 41 (expr -> expr LE term .)
    LE              reduce using rule 41 (expr -> expr LE term .)
    EQ              reduce using rule 41 (expr -> expr LE term .)
    NE              reduce using rule 41 (expr -> expr LE term .)
    AND             reduce using rule 41 (expr -> expr LE term .)
    OR              reduce using rule 41 (expr -> expr LE term .)
    NEWLINE         reduce using rule 41 (expr -> expr LE term .)
    PRINT           reduce using rule 41 (expr -> expr LE term .)
    IDENTIFIER      reduce using rule 41 (expr -> expr LE term .)
    IF              reduce using rule 41 (expr -> expr LE term .)
    WHILE           reduce using rule 41 (expr -> expr LE term .)
    FOR             reduce using rule 41 (expr -> expr LE term .)
    DEF             reduce using rule 41 (expr -> expr LE term .)
    RETURN          reduce using rule 41 (expr -> expr LE term .)
    BREAK           reduce using rule 41 (expr -> expr LE term .)
    CONTINUE        reduce using rule 41 (expr -> expr LE term .)
    TRY             reduce using rule 41 (expr -> expr LE term .)
    $end            reduce using rule 41 (expr -> expr LE term .)
    EXCEPT          reduce using rule 41 (expr -> expr LE term .)
    ELSE            reduce using rule 41 (expr -> expr LE term .)
    COLON           reduce using rule 41 (expr -> expr LE term .)
    RPAREN          reduce using rule 41 (expr -> expr LE term .)
    RBRACKET        reduce using rule 41 (expr -> expr LE term .)
    COMMA           reduce using rule 41 (expr -> expr LE term .)


state 96

    (42) expr -> expr EQ term .

    PLUS            reduce using rule 42 (expr -> expr EQ term .)
    MINUS           reduce using rule 42 (expr -> expr EQ term .)
    TIMES           reduce using rule 42 (expr -> expr EQ term .)
    DIVIDE          reduce using rule 42 (expr -> expr EQ term .)
    MODULO          reduce using rule 42 (expr -> expr EQ term .)
    GT              reduce using rule 42 (expr -> expr EQ term .)
    LT              reduce using rule 42 (expr -> expr EQ term .)
    GE              reduce using rule 42 (expr -> expr EQ term .)
    LE              reduce using rule 42 (expr -> expr EQ term .)
    EQ              reduce using rule 42 (expr -> expr EQ term .)
    NE              reduce using rule 42 (expr -> expr EQ term .)
    AND             reduce using rule 42 (expr -> expr EQ term .)
    OR              reduce using rule 42 (expr -> expr EQ term .)
    NEWLINE         reduce using rule 42 (expr -> expr EQ term .)
    PRINT           reduce using rule 42 (expr -> expr EQ term .)
    IDENTIFIER      reduce using rule 42 (expr -> expr EQ term .)
    IF              reduce using rule 42 (expr -> expr EQ term .)
    WHILE           reduce using rule 42 (expr -> expr EQ term .)
    FOR             reduce using rule 42 (expr -> expr EQ term .)
    DEF             reduce using rule 42 (expr -> expr EQ term .)
    RETURN          reduce using rule 42 (expr -> expr EQ term .)
    BREAK           reduce using rule 42 (expr -> expr EQ term .)
    CONTINUE        reduce using rule 42 (expr -> expr EQ term .)
    TRY             reduce using rule 42 (expr -> expr EQ term .)
    $end            reduce using rule 42 (expr -> expr EQ term .)
    EXCEPT          reduce using rule 42 (expr -> expr EQ term .)
    ELSE            reduce using rule 42 (expr -> expr EQ term .)
    COLON           reduce using rule 42 (expr -> expr EQ term .)
    RPAREN          reduce using rule 42 (expr -> expr EQ term .)
    RBRACKET        reduce using rule 42 (expr -> expr EQ term .)
    COMMA           reduce using rule 42 (expr -> expr EQ term .)


state 97

    (43) expr -> expr NE term .

    PLUS            reduce using rule 43 (expr -> expr NE term .)
    MINUS           reduce using rule 43 (expr -> expr NE term .)
    TIMES           reduce using rule 43 (expr -> expr NE term .)
    DIVIDE          reduce using rule 43 (expr -> expr NE term .)
    MODULO          reduce using rule 43 (expr -> expr NE term .)
    GT              reduce using rule 43 (expr -> expr NE term .)
    LT              reduce using rule 43 (expr -> expr NE term .)
    GE              reduce using rule 43 (expr -> expr NE term .)
    LE              reduce using rule 43 (expr -> expr NE term .)
    EQ              reduce using rule 43 (expr -> expr NE term .)
    NE              reduce using rule 43 (expr -> expr NE term .)
    AND             reduce using rule 43 (expr -> expr NE term .)
    OR              reduce using rule 43 (expr -> expr NE term .)
    NEWLINE         reduce using rule 43 (expr -> expr NE term .)
    PRINT           reduce using rule 43 (expr -> expr NE term .)
    IDENTIFIER      reduce using rule 43 (expr -> expr NE term .)
    IF              reduce using rule 43 (expr -> expr NE term .)
    WHILE           reduce using rule 43 (expr -> expr NE term .)
    FOR             reduce using rule 43 (expr -> expr NE term .)
    DEF             reduce using rule 43 (expr -> expr NE term .)
    RETURN          reduce using rule 43 (expr -> expr NE term .)
    BREAK           reduce using rule 43 (expr -> expr NE term .)
    CONTINUE        reduce using rule 43 (expr -> expr NE term .)
    TRY             reduce using rule 43 (expr -> expr NE term .)
    $end            reduce using rule 43 (expr -> expr NE term .)
    EXCEPT          reduce using rule 43 (expr -> expr NE term .)
    ELSE            reduce using rule 43 (expr -> expr NE term .)
    COLON           reduce using rule 43 (expr -> expr NE term .)
    RPAREN          reduce using rule 43 (expr -> expr NE term .)
    RBRACKET        reduce using rule 43 (expr -> expr NE term .)
    COMMA           reduce using rule 43 (expr -> expr NE term .)


state 98

    (44) expr -> expr AND term .

    PLUS            reduce using rule 44 (expr -> expr AND term .)
    MINUS           reduce using rule 44 (expr -> expr AND term .)
    TIMES           reduce using rule 44 (expr -> expr AND term .)
    DIVIDE          reduce using rule 44 (expr -> expr AND term .)
    MODULO          reduce using rule 44 (expr -> expr AND term .)
    GT              reduce using rule 44 (expr -> expr AND term .)
    LT              reduce using rule 44 (expr -> expr AND term .)
    GE              reduce using rule 44 (expr -> expr AND term .)
    LE              reduce using rule 44 (expr -> expr AND term .)
    EQ              reduce using rule 44 (expr -> expr AND term .)
    NE              reduce using rule 44 (expr -> expr AND term .)
    AND             reduce using rule 44 (expr -> expr AND term .)
    OR              reduce using rule 44 (expr -> expr AND term .)
    NEWLINE         reduce using rule 44 (expr -> expr AND term .)
    PRINT           reduce using rule 44 (expr -> expr AND term .)
    IDENTIFIER      reduce using rule 44 (expr -> expr AND term .)
    IF              reduce using rule 44 (expr -> expr AND term .)
    WHILE           reduce using rule 44 (expr -> expr AND term .)
    FOR             reduce using rule 44 (expr -> expr AND term .)
    DEF             reduce using rule 44 (expr -> expr AND term .)
    RETURN          reduce using rule 44 (expr -> expr AND term .)
    BREAK           reduce using rule 44 (expr -> expr AND term .)
    CONTINUE        reduce using rule 44 (expr -> expr AND term .)
    TRY             reduce using rule 44 (expr -> expr AND term .)
    $end            reduce using rule 44 (expr -> expr AND term .)
    EXCEPT          reduce using rule 44 (expr -> expr AND term .)
    ELSE            reduce using rule 44 (expr -> expr AND term .)
    COLON           reduce using rule 44 (expr -> expr AND term .)
    RPAREN          reduce using rule 44 (expr -> expr AND term .)
    RBRACKET        reduce using rule 44 (expr -> expr AND term .)
    COMMA           reduce using rule 44 (expr -> expr AND term .)


state 99

    (45) expr -> expr OR term .

    PLUS            reduce using rule 45 (expr -> expr OR term .)
    MINUS           reduce using rule 45 (expr -> expr OR term .)
    TIMES           reduce using rule 45 (expr -> expr OR term .)
    DIVIDE          reduce using rule 45 (expr -> expr OR term .)
    MODULO          reduce using rule 45 (expr -> expr OR term .)
    GT              reduce using rule 45 (expr -> expr OR term .)
    LT              reduce using rule 45 (expr -> expr OR term .)
    GE              reduce using rule 45 (expr -> expr OR term .)
    LE              reduce using rule 45 (expr -> expr OR term .)
    EQ              reduce using rule 45 (expr -> expr OR term .)
    NE              reduce using rule 45 (expr -> expr OR term .)
    AND             reduce using rule 45 (expr -> expr OR term .)
    OR              reduce using rule 45 (expr -> expr OR term .)
    NEWLINE         reduce using rule 45 (expr -> expr OR term .)
    PRINT           reduce using rule 45 (expr -> expr OR term .)
    IDENTIFIER      reduce using rule 45 (expr -> expr OR term .)
    IF              reduce using rule 45 (expr -> expr OR term .)
    WHILE           reduce using rule 45 (expr -> expr OR term .)
    FOR             reduce using rule 45 (expr -> expr OR term .)
    DEF             reduce using rule 45 (expr -> expr OR term .)
    RETURN          reduce using rule 45 (expr -> expr OR term .)
    BREAK           reduce using rule 45 (expr -> expr OR term .)
    CONTINUE        reduce using rule 45 (expr -> expr OR term .)
    TRY             reduce using rule 45 (expr -> expr OR term .)
    $end            reduce using rule 45 (expr -> expr OR term .)
    EXCEPT          reduce using rule 45 (expr -> expr OR term .)
    ELSE            reduce using rule 45 (expr -> expr OR term .)
    COLON           reduce using rule 45 (expr -> expr OR term .)
    RPAREN          reduce using rule 45 (expr -> expr OR term .)
    RBRACKET        reduce using rule 45 (expr -> expr OR term .)
    COMMA           reduce using rule 45 (expr -> expr OR term .)


state 100

    (61) list_expr -> IDENTIFIER LBRACKET expr . RBRACKET
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term
    (35) expr -> expr . TIMES term
    (36) expr -> expr . DIVIDE term
    (37) expr -> expr . MODULO term
    (38) expr -> expr . GT term
    (39) expr -> expr . LT term
    (40) expr -> expr . GE term
    (41) expr -> expr . LE term
    (42) expr -> expr . EQ term
    (43) expr -> expr . NE term
    (44) expr -> expr . AND term
    (45) expr -> expr . OR term

    RBRACKET        shift and go to state 118
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    GE              shift and go to state 62
    LE              shift and go to state 63
    EQ              shift and go to state 64
    NE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 101

    (65) function_call -> IDENTIFIER LPAREN expr_list . RPAREN
    (63) expr_list -> expr_list . COMMA expr

    RPAREN          shift and go to state 119
    COMMA           shift and go to state 105


state 102

    (66) function_call -> IDENTIFIER LPAREN RPAREN .

    PLUS            reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    MINUS           reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    TIMES           reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DIVIDE          reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    MODULO          reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    GT              reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LT              reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    GE              reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LE              reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    EQ              reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    NE              reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    AND             reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    OR              reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    NEWLINE         reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    PRINT           reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    IF              reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    WHILE           reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    FOR             reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DEF             reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RETURN          reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    BREAK           reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    CONTINUE        reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    TRY             reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    $end            reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    EXCEPT          reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    ELSE            reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    COLON           reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RBRACKET        reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 66 (function_call -> IDENTIFIER LPAREN RPAREN .)


state 103

    (67) string_method -> IDENTIFIER DOT IDENTIFIER . LPAREN expr_list RPAREN
    (68) string_method -> IDENTIFIER DOT IDENTIFIER . LPAREN RPAREN

    LPAREN          shift and go to state 120


state 104

    (60) list_expr -> LBRACKET expr_list RBRACKET .

    PLUS            reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    MINUS           reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    TIMES           reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    DIVIDE          reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    MODULO          reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    GT              reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    LT              reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    GE              reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    LE              reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    EQ              reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    NE              reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    AND             reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    OR              reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    NEWLINE         reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    PRINT           reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    IDENTIFIER      reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    IF              reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    WHILE           reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    FOR             reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    DEF             reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    RETURN          reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    BREAK           reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    CONTINUE        reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    TRY             reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    $end            reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    EXCEPT          reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    ELSE            reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    COLON           reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    RPAREN          reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    RBRACKET        reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)
    COMMA           reduce using rule 60 (list_expr -> LBRACKET expr_list RBRACKET .)


state 105

    (63) expr_list -> expr_list COMMA . expr
    (32) expr -> . term
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . expr TIMES term
    (36) expr -> . expr DIVIDE term
    (37) expr -> . expr MODULO term
    (38) expr -> . expr GT term
    (39) expr -> . expr LT term
    (40) expr -> . expr GE term
    (41) expr -> . expr LE term
    (42) expr -> . expr EQ term
    (43) expr -> . expr NE term
    (44) expr -> . expr AND term
    (45) expr -> . expr OR term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    expr                           shift and go to state 121
    term                           shift and go to state 28
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 106

    (69) len_function -> LEN LPAREN expr . RPAREN
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term
    (35) expr -> expr . TIMES term
    (36) expr -> expr . DIVIDE term
    (37) expr -> expr . MODULO term
    (38) expr -> expr . GT term
    (39) expr -> expr . LT term
    (40) expr -> expr . GE term
    (41) expr -> expr . LE term
    (42) expr -> expr . EQ term
    (43) expr -> expr . NE term
    (44) expr -> expr . AND term
    (45) expr -> expr . OR term

    RPAREN          shift and go to state 122
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    GE              shift and go to state 62
    LE              shift and go to state 63
    EQ              shift and go to state 64
    NE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 107

    (70) range_call -> RANGE LPAREN expr_list . RPAREN
    (63) expr_list -> expr_list . COMMA expr

    RPAREN          shift and go to state 123
    COMMA           shift and go to state 105


state 108

    (71) range_call -> RANGE LPAREN RPAREN .

    PLUS            reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    MINUS           reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    TIMES           reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    DIVIDE          reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    MODULO          reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    GT              reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    LT              reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    GE              reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    LE              reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    EQ              reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    NE              reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    AND             reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    OR              reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    NEWLINE         reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    PRINT           reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    IF              reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    WHILE           reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    FOR             reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    DEF             reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    RETURN          reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    BREAK           reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    CONTINUE        reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    TRY             reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    $end            reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    EXCEPT          reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    ELSE            reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    COLON           reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    RPAREN          reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    RBRACKET        reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)
    COMMA           reduce using rule 71 (range_call -> RANGE LPAREN RPAREN .)


state 109

    (18) assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET . EQUALS expr

    EQUALS          shift and go to state 124


state 110

    (19) if_stmt -> IF expr COLON statements .
    (20) if_stmt -> IF expr COLON statements . ELSE COLON statements
    (3) statements -> statements . statement
    (4) statement -> . print_stmt
    (5) statement -> . assign_stmt
    (6) statement -> . if_stmt
    (7) statement -> . while_stmt
    (8) statement -> . for_stmt
    (9) statement -> . function_def
    (10) statement -> . return_stmt
    (11) statement -> . break_stmt
    (12) statement -> . continue_stmt
    (13) statement -> . try_except_stmt
    (14) statement -> . NEWLINE
    (15) print_stmt -> . PRINT LPAREN expr RPAREN
    (16) print_stmt -> . PRINT expr
    (17) assign_stmt -> . IDENTIFIER EQUALS expr
    (18) assign_stmt -> . IDENTIFIER LBRACKET expr RBRACKET EQUALS expr
    (19) if_stmt -> . IF expr COLON statements
    (20) if_stmt -> . IF expr COLON statements ELSE COLON statements
    (21) while_stmt -> . WHILE expr COLON statements
    (22) for_stmt -> . FOR IDENTIFIER IN expr COLON statements
    (23) function_def -> . DEF IDENTIFIER LPAREN param_list RPAREN COLON statements
    (27) return_stmt -> . RETURN expr
    (28) return_stmt -> . RETURN
    (29) break_stmt -> . BREAK
    (30) continue_stmt -> . CONTINUE
    (31) try_except_stmt -> . TRY COLON statements EXCEPT COLON statements

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
    $end            reduce using rule 19 (if_stmt -> IF expr COLON statements .)
    EXCEPT          reduce using rule 19 (if_stmt -> IF expr COLON statements .)
    ELSE            shift and go to state 125
    NEWLINE         shift and go to state 14
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19
    DEF             shift and go to state 20
    RETURN          shift and go to state 21
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    TRY             shift and go to state 24

  ! NEWLINE         [ reduce using rule 19 (if_stmt -> IF expr COLON statements .) ]
  ! PRINT           [ reduce using rule 19 (if_stmt -> IF expr COLON statements .) ]
  ! IDENTIFIER      [ reduce using rule 19 (if_stmt -> IF expr COLON statements .) ]
  ! IF              [ reduce using rule 19 (if_stmt -> IF expr COLON statements .) ]
  ! WHILE           [ reduce using rule 19 (if_stmt -> IF expr COLON statements .) ]
  ! FOR             [ reduce using rule 19 (if_stmt -> IF expr COLON statements .) ]
  ! DEF             [ reduce using rule 19 (if_stmt -> IF expr COLON statements .) ]
  ! RETURN          [ reduce using rule 19 (if_stmt -> IF expr COLON statements .) ]
  ! BREAK           [ reduce using rule 19 (if_stmt -> IF expr COLON statements .) ]
  ! CONTINUE        [ reduce using rule 19 (if_stmt -> IF expr COLON statements .) ]
  ! TRY             [ reduce using rule 19 (if_stmt -> IF expr COLON statements .) ]
  ! ELSE            [ reduce using rule 19 (if_stmt -> IF expr COLON statements .) ]

    statement                      shift and go to state 25
    print_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    if_stmt                        shift and go to state 6
    while_stmt                     shift and go to state 7
    for_stmt                       shift and go to state 8
    function_def                   shift and go to state 9
    return_stmt                    shift and go to state 10
    break_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    try_except_stmt                shift and go to state 13

state 111

    (59) factor -> LPAREN expr RPAREN .

    COLON           reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    MODULO          reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    GT              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    LT              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    GE              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    LE              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    EQ              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    NE              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    AND             reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    OR              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    NEWLINE         reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    PRINT           reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    IDENTIFIER      reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    IF              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    WHILE           reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    FOR             reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    DEF             reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    RETURN          reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    BREAK           reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    CONTINUE        reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    TRY             reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    $end            reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    EXCEPT          reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    ELSE            reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 59 (factor -> LPAREN expr RPAREN .)


state 112

    (21) while_stmt -> WHILE expr COLON statements .
    (3) statements -> statements . statement
    (4) statement -> . print_stmt
    (5) statement -> . assign_stmt
    (6) statement -> . if_stmt
    (7) statement -> . while_stmt
    (8) statement -> . for_stmt
    (9) statement -> . function_def
    (10) statement -> . return_stmt
    (11) statement -> . break_stmt
    (12) statement -> . continue_stmt
    (13) statement -> . try_except_stmt
    (14) statement -> . NEWLINE
    (15) print_stmt -> . PRINT LPAREN expr RPAREN
    (16) print_stmt -> . PRINT expr
    (17) assign_stmt -> . IDENTIFIER EQUALS expr
    (18) assign_stmt -> . IDENTIFIER LBRACKET expr RBRACKET EQUALS expr
    (19) if_stmt -> . IF expr COLON statements
    (20) if_stmt -> . IF expr COLON statements ELSE COLON statements
    (21) while_stmt -> . WHILE expr COLON statements
    (22) for_stmt -> . FOR IDENTIFIER IN expr COLON statements
    (23) function_def -> . DEF IDENTIFIER LPAREN param_list RPAREN COLON statements
    (27) return_stmt -> . RETURN expr
    (28) return_stmt -> . RETURN
    (29) break_stmt -> . BREAK
    (30) continue_stmt -> . CONTINUE
    (31) try_except_stmt -> . TRY COLON statements EXCEPT COLON statements

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
    $end            reduce using rule 21 (while_stmt -> WHILE expr COLON statements .)
    EXCEPT          reduce using rule 21 (while_stmt -> WHILE expr COLON statements .)
    ELSE            reduce using rule 21 (while_stmt -> WHILE expr COLON statements .)
    NEWLINE         shift and go to state 14
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19
    DEF             shift and go to state 20
    RETURN          shift and go to state 21
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    TRY             shift and go to state 24

  ! NEWLINE         [ reduce using rule 21 (while_stmt -> WHILE expr COLON statements .) ]
  ! PRINT           [ reduce using rule 21 (while_stmt -> WHILE expr COLON statements .) ]
  ! IDENTIFIER      [ reduce using rule 21 (while_stmt -> WHILE expr COLON statements .) ]
  ! IF              [ reduce using rule 21 (while_stmt -> WHILE expr COLON statements .) ]
  ! WHILE           [ reduce using rule 21 (while_stmt -> WHILE expr COLON statements .) ]
  ! FOR             [ reduce using rule 21 (while_stmt -> WHILE expr COLON statements .) ]
  ! DEF             [ reduce using rule 21 (while_stmt -> WHILE expr COLON statements .) ]
  ! RETURN          [ reduce using rule 21 (while_stmt -> WHILE expr COLON statements .) ]
  ! BREAK           [ reduce using rule 21 (while_stmt -> WHILE expr COLON statements .) ]
  ! CONTINUE        [ reduce using rule 21 (while_stmt -> WHILE expr COLON statements .) ]
  ! TRY             [ reduce using rule 21 (while_stmt -> WHILE expr COLON statements .) ]

    statement                      shift and go to state 25
    print_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    if_stmt                        shift and go to state 6
    while_stmt                     shift and go to state 7
    for_stmt                       shift and go to state 8
    function_def                   shift and go to state 9
    return_stmt                    shift and go to state 10
    break_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    try_except_stmt                shift and go to state 13

state 113

    (22) for_stmt -> FOR IDENTIFIER IN expr . COLON statements
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term
    (35) expr -> expr . TIMES term
    (36) expr -> expr . DIVIDE term
    (37) expr -> expr . MODULO term
    (38) expr -> expr . GT term
    (39) expr -> expr . LT term
    (40) expr -> expr . GE term
    (41) expr -> expr . LE term
    (42) expr -> expr . EQ term
    (43) expr -> expr . NE term
    (44) expr -> expr . AND term
    (45) expr -> expr . OR term

    COLON           shift and go to state 126
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    GE              shift and go to state 62
    LE              shift and go to state 63
    EQ              shift and go to state 64
    NE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 114

    (24) param_list -> IDENTIFIER .

    RPAREN          reduce using rule 24 (param_list -> IDENTIFIER .)
    COMMA           reduce using rule 24 (param_list -> IDENTIFIER .)


state 115

    (23) function_def -> DEF IDENTIFIER LPAREN param_list . RPAREN COLON statements
    (25) param_list -> param_list . COMMA IDENTIFIER

    RPAREN          shift and go to state 127
    COMMA           shift and go to state 128


state 116

    (26) param_list -> empty .

    RPAREN          reduce using rule 26 (param_list -> empty .)
    COMMA           reduce using rule 26 (param_list -> empty .)


state 117

    (31) try_except_stmt -> TRY COLON statements EXCEPT . COLON statements

    COLON           shift and go to state 129


state 118

    (61) list_expr -> IDENTIFIER LBRACKET expr RBRACKET .

    PLUS            reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    MODULO          reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    GT              reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    LT              reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    GE              reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    LE              reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    EQ              reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    NE              reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    AND             reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    OR              reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    NEWLINE         reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    PRINT           reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    IDENTIFIER      reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    IF              reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    WHILE           reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    FOR             reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    DEF             reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    RETURN          reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    BREAK           reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    CONTINUE        reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    TRY             reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    $end            reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    EXCEPT          reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    ELSE            reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    COLON           reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 61 (list_expr -> IDENTIFIER LBRACKET expr RBRACKET .)


state 119

    (65) function_call -> IDENTIFIER LPAREN expr_list RPAREN .

    PLUS            reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    MINUS           reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    TIMES           reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    DIVIDE          reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    MODULO          reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    GT              reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    LT              reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    GE              reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    LE              reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    EQ              reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    NE              reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    AND             reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    OR              reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    NEWLINE         reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    PRINT           reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    IDENTIFIER      reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    IF              reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    WHILE           reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    FOR             reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    DEF             reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    RETURN          reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    BREAK           reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    CONTINUE        reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    TRY             reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    $end            reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    EXCEPT          reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    ELSE            reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    COLON           reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    RPAREN          reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    RBRACKET        reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)
    COMMA           reduce using rule 65 (function_call -> IDENTIFIER LPAREN expr_list RPAREN .)


state 120

    (67) string_method -> IDENTIFIER DOT IDENTIFIER LPAREN . expr_list RPAREN
    (68) string_method -> IDENTIFIER DOT IDENTIFIER LPAREN . RPAREN
    (62) expr_list -> . expr
    (63) expr_list -> . expr_list COMMA expr
    (64) expr_list -> . empty
    (32) expr -> . term
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . expr TIMES term
    (36) expr -> . expr DIVIDE term
    (37) expr -> . expr MODULO term
    (38) expr -> . expr GT term
    (39) expr -> . expr LT term
    (40) expr -> . expr GE term
    (41) expr -> . expr LE term
    (42) expr -> . expr EQ term
    (43) expr -> . expr NE term
    (44) expr -> . expr AND term
    (45) expr -> . expr OR term
    (76) empty -> .
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 131
    COMMA           reduce using rule 76 (empty -> .)
    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

  ! RPAREN          [ reduce using rule 76 (empty -> .) ]

    expr_list                      shift and go to state 130
    expr                           shift and go to state 74
    empty                          shift and go to state 75
    term                           shift and go to state 28
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 121

    (63) expr_list -> expr_list COMMA expr .
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term
    (35) expr -> expr . TIMES term
    (36) expr -> expr . DIVIDE term
    (37) expr -> expr . MODULO term
    (38) expr -> expr . GT term
    (39) expr -> expr . LT term
    (40) expr -> expr . GE term
    (41) expr -> expr . LE term
    (42) expr -> expr . EQ term
    (43) expr -> expr . NE term
    (44) expr -> expr . AND term
    (45) expr -> expr . OR term

    RBRACKET        reduce using rule 63 (expr_list -> expr_list COMMA expr .)
    COMMA           reduce using rule 63 (expr_list -> expr_list COMMA expr .)
    RPAREN          reduce using rule 63 (expr_list -> expr_list COMMA expr .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    GE              shift and go to state 62
    LE              shift and go to state 63
    EQ              shift and go to state 64
    NE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 122

    (69) len_function -> LEN LPAREN expr RPAREN .

    PLUS            reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    MINUS           reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    TIMES           reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    MODULO          reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    GT              reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    LT              reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    GE              reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    LE              reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    EQ              reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    NE              reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    AND             reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    OR              reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    NEWLINE         reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    PRINT           reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    IDENTIFIER      reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    IF              reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    WHILE           reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    FOR             reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    DEF             reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    RETURN          reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    BREAK           reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    CONTINUE        reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    TRY             reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    $end            reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    EXCEPT          reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    ELSE            reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    COLON           reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    RPAREN          reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)
    COMMA           reduce using rule 69 (len_function -> LEN LPAREN expr RPAREN .)


state 123

    (70) range_call -> RANGE LPAREN expr_list RPAREN .

    PLUS            reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    MINUS           reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    TIMES           reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    DIVIDE          reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    MODULO          reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    GT              reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    LT              reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    GE              reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    LE              reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    EQ              reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    NE              reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    AND             reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    OR              reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    NEWLINE         reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    PRINT           reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    IDENTIFIER      reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    IF              reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    WHILE           reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    FOR             reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    DEF             reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    RETURN          reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    BREAK           reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    CONTINUE        reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    TRY             reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    $end            reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    EXCEPT          reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    ELSE            reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    COLON           reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    RPAREN          reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    RBRACKET        reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)
    COMMA           reduce using rule 70 (range_call -> RANGE LPAREN expr_list RPAREN .)


state 124

    (18) assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET EQUALS . expr
    (32) expr -> . term
    (33) expr -> . expr PLUS term
    (34) expr -> . expr MINUS term
    (35) expr -> . expr TIMES term
    (36) expr -> . expr DIVIDE term
    (37) expr -> . expr MODULO term
    (38) expr -> . expr GT term
    (39) expr -> . expr LT term
    (40) expr -> . expr GE term
    (41) expr -> . expr LE term
    (42) expr -> . expr EQ term
    (43) expr -> . expr NE term
    (44) expr -> . expr AND term
    (45) expr -> . expr OR term
    (46) term -> . factor
    (47) term -> . NOT term
    (48) term -> . MINUS term
    (49) factor -> . NUMBER
    (50) factor -> . STRING
    (51) factor -> . TRUE
    (52) factor -> . FALSE
    (53) factor -> . IDENTIFIER
    (54) factor -> . list_expr
    (55) factor -> . function_call
    (56) factor -> . string_method
    (57) factor -> . len_function
    (58) factor -> . range_call
    (59) factor -> . LPAREN expr RPAREN
    (60) list_expr -> . LBRACKET expr_list RBRACKET
    (61) list_expr -> . IDENTIFIER LBRACKET expr RBRACKET
    (65) function_call -> . IDENTIFIER LPAREN expr_list RPAREN
    (66) function_call -> . IDENTIFIER LPAREN RPAREN
    (67) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN
    (68) string_method -> . IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
    (69) len_function -> . LEN LPAREN expr RPAREN
    (70) range_call -> . RANGE LPAREN expr_list RPAREN
    (71) range_call -> . RANGE LPAREN RPAREN

    NOT             shift and go to state 31
    MINUS           shift and go to state 29
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    IDENTIFIER      shift and go to state 36
    LPAREN          shift and go to state 48
    LBRACKET        shift and go to state 42
    LEN             shift and go to state 43
    RANGE           shift and go to state 44

    expr                           shift and go to state 132
    term                           shift and go to state 28
    factor                         shift and go to state 30
    list_expr                      shift and go to state 37
    function_call                  shift and go to state 38
    string_method                  shift and go to state 39
    len_function                   shift and go to state 40
    range_call                     shift and go to state 41

state 125

    (20) if_stmt -> IF expr COLON statements ELSE . COLON statements

    COLON           shift and go to state 133


state 126

    (22) for_stmt -> FOR IDENTIFIER IN expr COLON . statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . print_stmt
    (5) statement -> . assign_stmt
    (6) statement -> . if_stmt
    (7) statement -> . while_stmt
    (8) statement -> . for_stmt
    (9) statement -> . function_def
    (10) statement -> . return_stmt
    (11) statement -> . break_stmt
    (12) statement -> . continue_stmt
    (13) statement -> . try_except_stmt
    (14) statement -> . NEWLINE
    (15) print_stmt -> . PRINT LPAREN expr RPAREN
    (16) print_stmt -> . PRINT expr
    (17) assign_stmt -> . IDENTIFIER EQUALS expr
    (18) assign_stmt -> . IDENTIFIER LBRACKET expr RBRACKET EQUALS expr
    (19) if_stmt -> . IF expr COLON statements
    (20) if_stmt -> . IF expr COLON statements ELSE COLON statements
    (21) while_stmt -> . WHILE expr COLON statements
    (22) for_stmt -> . FOR IDENTIFIER IN expr COLON statements
    (23) function_def -> . DEF IDENTIFIER LPAREN param_list RPAREN COLON statements
    (27) return_stmt -> . RETURN expr
    (28) return_stmt -> . RETURN
    (29) break_stmt -> . BREAK
    (30) continue_stmt -> . CONTINUE
    (31) try_except_stmt -> . TRY COLON statements EXCEPT COLON statements

    NEWLINE         shift and go to state 14
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19
    DEF             shift and go to state 20
    RETURN          shift and go to state 21
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    TRY             shift and go to state 24

    statements                     shift and go to state 134
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    if_stmt                        shift and go to state 6
    while_stmt                     shift and go to state 7
    for_stmt                       shift and go to state 8
    function_def                   shift and go to state 9
    return_stmt                    shift and go to state 10
    break_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    try_except_stmt                shift and go to state 13

state 127

    (23) function_def -> DEF IDENTIFIER LPAREN param_list RPAREN . COLON statements

    COLON           shift and go to state 135


state 128

    (25) param_list -> param_list COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 136


state 129

    (31) try_except_stmt -> TRY COLON statements EXCEPT COLON . statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . print_stmt
    (5) statement -> . assign_stmt
    (6) statement -> . if_stmt
    (7) statement -> . while_stmt
    (8) statement -> . for_stmt
    (9) statement -> . function_def
    (10) statement -> . return_stmt
    (11) statement -> . break_stmt
    (12) statement -> . continue_stmt
    (13) statement -> . try_except_stmt
    (14) statement -> . NEWLINE
    (15) print_stmt -> . PRINT LPAREN expr RPAREN
    (16) print_stmt -> . PRINT expr
    (17) assign_stmt -> . IDENTIFIER EQUALS expr
    (18) assign_stmt -> . IDENTIFIER LBRACKET expr RBRACKET EQUALS expr
    (19) if_stmt -> . IF expr COLON statements
    (20) if_stmt -> . IF expr COLON statements ELSE COLON statements
    (21) while_stmt -> . WHILE expr COLON statements
    (22) for_stmt -> . FOR IDENTIFIER IN expr COLON statements
    (23) function_def -> . DEF IDENTIFIER LPAREN param_list RPAREN COLON statements
    (27) return_stmt -> . RETURN expr
    (28) return_stmt -> . RETURN
    (29) break_stmt -> . BREAK
    (30) continue_stmt -> . CONTINUE
    (31) try_except_stmt -> . TRY COLON statements EXCEPT COLON statements

    NEWLINE         shift and go to state 14
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19
    DEF             shift and go to state 20
    RETURN          shift and go to state 21
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    TRY             shift and go to state 24

    statements                     shift and go to state 137
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    if_stmt                        shift and go to state 6
    while_stmt                     shift and go to state 7
    for_stmt                       shift and go to state 8
    function_def                   shift and go to state 9
    return_stmt                    shift and go to state 10
    break_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    try_except_stmt                shift and go to state 13

state 130

    (67) string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list . RPAREN
    (63) expr_list -> expr_list . COMMA expr

    RPAREN          shift and go to state 138
    COMMA           shift and go to state 105


state 131

    (68) string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .

    PLUS            reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    MINUS           reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    TIMES           reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    DIVIDE          reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    MODULO          reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    GT              reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    LT              reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    GE              reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    LE              reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    EQ              reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    NE              reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    AND             reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    OR              reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    NEWLINE         reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    PRINT           reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    IF              reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    WHILE           reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    FOR             reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    DEF             reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    RETURN          reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    BREAK           reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    CONTINUE        reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    TRY             reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    $end            reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    EXCEPT          reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    ELSE            reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    COLON           reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    RBRACKET        reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 68 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN .)


state 132

    (18) assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET EQUALS expr .
    (33) expr -> expr . PLUS term
    (34) expr -> expr . MINUS term
    (35) expr -> expr . TIMES term
    (36) expr -> expr . DIVIDE term
    (37) expr -> expr . MODULO term
    (38) expr -> expr . GT term
    (39) expr -> expr . LT term
    (40) expr -> expr . GE term
    (41) expr -> expr . LE term
    (42) expr -> expr . EQ term
    (43) expr -> expr . NE term
    (44) expr -> expr . AND term
    (45) expr -> expr . OR term

    NEWLINE         reduce using rule 18 (assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET EQUALS expr .)
    PRINT           reduce using rule 18 (assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET EQUALS expr .)
    IDENTIFIER      reduce using rule 18 (assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET EQUALS expr .)
    IF              reduce using rule 18 (assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET EQUALS expr .)
    WHILE           reduce using rule 18 (assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET EQUALS expr .)
    FOR             reduce using rule 18 (assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET EQUALS expr .)
    DEF             reduce using rule 18 (assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET EQUALS expr .)
    RETURN          reduce using rule 18 (assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET EQUALS expr .)
    BREAK           reduce using rule 18 (assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET EQUALS expr .)
    CONTINUE        reduce using rule 18 (assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET EQUALS expr .)
    TRY             reduce using rule 18 (assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET EQUALS expr .)
    $end            reduce using rule 18 (assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET EQUALS expr .)
    EXCEPT          reduce using rule 18 (assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET EQUALS expr .)
    ELSE            reduce using rule 18 (assign_stmt -> IDENTIFIER LBRACKET expr RBRACKET EQUALS expr .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 56
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MODULO          shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    GE              shift and go to state 62
    LE              shift and go to state 63
    EQ              shift and go to state 64
    NE              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 133

    (20) if_stmt -> IF expr COLON statements ELSE COLON . statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . print_stmt
    (5) statement -> . assign_stmt
    (6) statement -> . if_stmt
    (7) statement -> . while_stmt
    (8) statement -> . for_stmt
    (9) statement -> . function_def
    (10) statement -> . return_stmt
    (11) statement -> . break_stmt
    (12) statement -> . continue_stmt
    (13) statement -> . try_except_stmt
    (14) statement -> . NEWLINE
    (15) print_stmt -> . PRINT LPAREN expr RPAREN
    (16) print_stmt -> . PRINT expr
    (17) assign_stmt -> . IDENTIFIER EQUALS expr
    (18) assign_stmt -> . IDENTIFIER LBRACKET expr RBRACKET EQUALS expr
    (19) if_stmt -> . IF expr COLON statements
    (20) if_stmt -> . IF expr COLON statements ELSE COLON statements
    (21) while_stmt -> . WHILE expr COLON statements
    (22) for_stmt -> . FOR IDENTIFIER IN expr COLON statements
    (23) function_def -> . DEF IDENTIFIER LPAREN param_list RPAREN COLON statements
    (27) return_stmt -> . RETURN expr
    (28) return_stmt -> . RETURN
    (29) break_stmt -> . BREAK
    (30) continue_stmt -> . CONTINUE
    (31) try_except_stmt -> . TRY COLON statements EXCEPT COLON statements

    NEWLINE         shift and go to state 14
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19
    DEF             shift and go to state 20
    RETURN          shift and go to state 21
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    TRY             shift and go to state 24

    statements                     shift and go to state 139
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    if_stmt                        shift and go to state 6
    while_stmt                     shift and go to state 7
    for_stmt                       shift and go to state 8
    function_def                   shift and go to state 9
    return_stmt                    shift and go to state 10
    break_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    try_except_stmt                shift and go to state 13

state 134

    (22) for_stmt -> FOR IDENTIFIER IN expr COLON statements .
    (3) statements -> statements . statement
    (4) statement -> . print_stmt
    (5) statement -> . assign_stmt
    (6) statement -> . if_stmt
    (7) statement -> . while_stmt
    (8) statement -> . for_stmt
    (9) statement -> . function_def
    (10) statement -> . return_stmt
    (11) statement -> . break_stmt
    (12) statement -> . continue_stmt
    (13) statement -> . try_except_stmt
    (14) statement -> . NEWLINE
    (15) print_stmt -> . PRINT LPAREN expr RPAREN
    (16) print_stmt -> . PRINT expr
    (17) assign_stmt -> . IDENTIFIER EQUALS expr
    (18) assign_stmt -> . IDENTIFIER LBRACKET expr RBRACKET EQUALS expr
    (19) if_stmt -> . IF expr COLON statements
    (20) if_stmt -> . IF expr COLON statements ELSE COLON statements
    (21) while_stmt -> . WHILE expr COLON statements
    (22) for_stmt -> . FOR IDENTIFIER IN expr COLON statements
    (23) function_def -> . DEF IDENTIFIER LPAREN param_list RPAREN COLON statements
    (27) return_stmt -> . RETURN expr
    (28) return_stmt -> . RETURN
    (29) break_stmt -> . BREAK
    (30) continue_stmt -> . CONTINUE
    (31) try_except_stmt -> . TRY COLON statements EXCEPT COLON statements

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
    $end            reduce using rule 22 (for_stmt -> FOR IDENTIFIER IN expr COLON statements .)
    EXCEPT          reduce using rule 22 (for_stmt -> FOR IDENTIFIER IN expr COLON statements .)
    ELSE            reduce using rule 22 (for_stmt -> FOR IDENTIFIER IN expr COLON statements .)
    NEWLINE         shift and go to state 14
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19
    DEF             shift and go to state 20
    RETURN          shift and go to state 21
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    TRY             shift and go to state 24

  ! NEWLINE         [ reduce using rule 22 (for_stmt -> FOR IDENTIFIER IN expr COLON statements .) ]
  ! PRINT           [ reduce using rule 22 (for_stmt -> FOR IDENTIFIER IN expr COLON statements .) ]
  ! IDENTIFIER      [ reduce using rule 22 (for_stmt -> FOR IDENTIFIER IN expr COLON statements .) ]
  ! IF              [ reduce using rule 22 (for_stmt -> FOR IDENTIFIER IN expr COLON statements .) ]
  ! WHILE           [ reduce using rule 22 (for_stmt -> FOR IDENTIFIER IN expr COLON statements .) ]
  ! FOR             [ reduce using rule 22 (for_stmt -> FOR IDENTIFIER IN expr COLON statements .) ]
  ! DEF             [ reduce using rule 22 (for_stmt -> FOR IDENTIFIER IN expr COLON statements .) ]
  ! RETURN          [ reduce using rule 22 (for_stmt -> FOR IDENTIFIER IN expr COLON statements .) ]
  ! BREAK           [ reduce using rule 22 (for_stmt -> FOR IDENTIFIER IN expr COLON statements .) ]
  ! CONTINUE        [ reduce using rule 22 (for_stmt -> FOR IDENTIFIER IN expr COLON statements .) ]
  ! TRY             [ reduce using rule 22 (for_stmt -> FOR IDENTIFIER IN expr COLON statements .) ]

    statement                      shift and go to state 25
    print_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    if_stmt                        shift and go to state 6
    while_stmt                     shift and go to state 7
    for_stmt                       shift and go to state 8
    function_def                   shift and go to state 9
    return_stmt                    shift and go to state 10
    break_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    try_except_stmt                shift and go to state 13

state 135

    (23) function_def -> DEF IDENTIFIER LPAREN param_list RPAREN COLON . statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . print_stmt
    (5) statement -> . assign_stmt
    (6) statement -> . if_stmt
    (7) statement -> . while_stmt
    (8) statement -> . for_stmt
    (9) statement -> . function_def
    (10) statement -> . return_stmt
    (11) statement -> . break_stmt
    (12) statement -> . continue_stmt
    (13) statement -> . try_except_stmt
    (14) statement -> . NEWLINE
    (15) print_stmt -> . PRINT LPAREN expr RPAREN
    (16) print_stmt -> . PRINT expr
    (17) assign_stmt -> . IDENTIFIER EQUALS expr
    (18) assign_stmt -> . IDENTIFIER LBRACKET expr RBRACKET EQUALS expr
    (19) if_stmt -> . IF expr COLON statements
    (20) if_stmt -> . IF expr COLON statements ELSE COLON statements
    (21) while_stmt -> . WHILE expr COLON statements
    (22) for_stmt -> . FOR IDENTIFIER IN expr COLON statements
    (23) function_def -> . DEF IDENTIFIER LPAREN param_list RPAREN COLON statements
    (27) return_stmt -> . RETURN expr
    (28) return_stmt -> . RETURN
    (29) break_stmt -> . BREAK
    (30) continue_stmt -> . CONTINUE
    (31) try_except_stmt -> . TRY COLON statements EXCEPT COLON statements

    NEWLINE         shift and go to state 14
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19
    DEF             shift and go to state 20
    RETURN          shift and go to state 21
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    TRY             shift and go to state 24

    statements                     shift and go to state 140
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    if_stmt                        shift and go to state 6
    while_stmt                     shift and go to state 7
    for_stmt                       shift and go to state 8
    function_def                   shift and go to state 9
    return_stmt                    shift and go to state 10
    break_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    try_except_stmt                shift and go to state 13

state 136

    (25) param_list -> param_list COMMA IDENTIFIER .

    RPAREN          reduce using rule 25 (param_list -> param_list COMMA IDENTIFIER .)
    COMMA           reduce using rule 25 (param_list -> param_list COMMA IDENTIFIER .)


state 137

    (31) try_except_stmt -> TRY COLON statements EXCEPT COLON statements .
    (3) statements -> statements . statement
    (4) statement -> . print_stmt
    (5) statement -> . assign_stmt
    (6) statement -> . if_stmt
    (7) statement -> . while_stmt
    (8) statement -> . for_stmt
    (9) statement -> . function_def
    (10) statement -> . return_stmt
    (11) statement -> . break_stmt
    (12) statement -> . continue_stmt
    (13) statement -> . try_except_stmt
    (14) statement -> . NEWLINE
    (15) print_stmt -> . PRINT LPAREN expr RPAREN
    (16) print_stmt -> . PRINT expr
    (17) assign_stmt -> . IDENTIFIER EQUALS expr
    (18) assign_stmt -> . IDENTIFIER LBRACKET expr RBRACKET EQUALS expr
    (19) if_stmt -> . IF expr COLON statements
    (20) if_stmt -> . IF expr COLON statements ELSE COLON statements
    (21) while_stmt -> . WHILE expr COLON statements
    (22) for_stmt -> . FOR IDENTIFIER IN expr COLON statements
    (23) function_def -> . DEF IDENTIFIER LPAREN param_list RPAREN COLON statements
    (27) return_stmt -> . RETURN expr
    (28) return_stmt -> . RETURN
    (29) break_stmt -> . BREAK
    (30) continue_stmt -> . CONTINUE
    (31) try_except_stmt -> . TRY COLON statements EXCEPT COLON statements

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
    $end            reduce using rule 31 (try_except_stmt -> TRY COLON statements EXCEPT COLON statements .)
    EXCEPT          reduce using rule 31 (try_except_stmt -> TRY COLON statements EXCEPT COLON statements .)
    ELSE            reduce using rule 31 (try_except_stmt -> TRY COLON statements EXCEPT COLON statements .)
    NEWLINE         shift and go to state 14
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19
    DEF             shift and go to state 20
    RETURN          shift and go to state 21
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    TRY             shift and go to state 24

  ! NEWLINE         [ reduce using rule 31 (try_except_stmt -> TRY COLON statements EXCEPT COLON statements .) ]
  ! PRINT           [ reduce using rule 31 (try_except_stmt -> TRY COLON statements EXCEPT COLON statements .) ]
  ! IDENTIFIER      [ reduce using rule 31 (try_except_stmt -> TRY COLON statements EXCEPT COLON statements .) ]
  ! IF              [ reduce using rule 31 (try_except_stmt -> TRY COLON statements EXCEPT COLON statements .) ]
  ! WHILE           [ reduce using rule 31 (try_except_stmt -> TRY COLON statements EXCEPT COLON statements .) ]
  ! FOR             [ reduce using rule 31 (try_except_stmt -> TRY COLON statements EXCEPT COLON statements .) ]
  ! DEF             [ reduce using rule 31 (try_except_stmt -> TRY COLON statements EXCEPT COLON statements .) ]
  ! RETURN          [ reduce using rule 31 (try_except_stmt -> TRY COLON statements EXCEPT COLON statements .) ]
  ! BREAK           [ reduce using rule 31 (try_except_stmt -> TRY COLON statements EXCEPT COLON statements .) ]
  ! CONTINUE        [ reduce using rule 31 (try_except_stmt -> TRY COLON statements EXCEPT COLON statements .) ]
  ! TRY             [ reduce using rule 31 (try_except_stmt -> TRY COLON statements EXCEPT COLON statements .) ]

    statement                      shift and go to state 25
    print_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    if_stmt                        shift and go to state 6
    while_stmt                     shift and go to state 7
    for_stmt                       shift and go to state 8
    function_def                   shift and go to state 9
    return_stmt                    shift and go to state 10
    break_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    try_except_stmt                shift and go to state 13

state 138

    (67) string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .

    PLUS            reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    MINUS           reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    TIMES           reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    DIVIDE          reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    MODULO          reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    GT              reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    LT              reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    GE              reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    LE              reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    EQ              reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    NE              reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    AND             reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    OR              reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    NEWLINE         reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    PRINT           reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    IDENTIFIER      reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    IF              reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    WHILE           reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    FOR             reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    DEF             reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    RETURN          reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    BREAK           reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    CONTINUE        reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    TRY             reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    $end            reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    EXCEPT          reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    ELSE            reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    COLON           reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    RPAREN          reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    RBRACKET        reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)
    COMMA           reduce using rule 67 (string_method -> IDENTIFIER DOT IDENTIFIER LPAREN expr_list RPAREN .)


state 139

    (20) if_stmt -> IF expr COLON statements ELSE COLON statements .
    (3) statements -> statements . statement
    (4) statement -> . print_stmt
    (5) statement -> . assign_stmt
    (6) statement -> . if_stmt
    (7) statement -> . while_stmt
    (8) statement -> . for_stmt
    (9) statement -> . function_def
    (10) statement -> . return_stmt
    (11) statement -> . break_stmt
    (12) statement -> . continue_stmt
    (13) statement -> . try_except_stmt
    (14) statement -> . NEWLINE
    (15) print_stmt -> . PRINT LPAREN expr RPAREN
    (16) print_stmt -> . PRINT expr
    (17) assign_stmt -> . IDENTIFIER EQUALS expr
    (18) assign_stmt -> . IDENTIFIER LBRACKET expr RBRACKET EQUALS expr
    (19) if_stmt -> . IF expr COLON statements
    (20) if_stmt -> . IF expr COLON statements ELSE COLON statements
    (21) while_stmt -> . WHILE expr COLON statements
    (22) for_stmt -> . FOR IDENTIFIER IN expr COLON statements
    (23) function_def -> . DEF IDENTIFIER LPAREN param_list RPAREN COLON statements
    (27) return_stmt -> . RETURN expr
    (28) return_stmt -> . RETURN
    (29) break_stmt -> . BREAK
    (30) continue_stmt -> . CONTINUE
    (31) try_except_stmt -> . TRY COLON statements EXCEPT COLON statements

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
    $end            reduce using rule 20 (if_stmt -> IF expr COLON statements ELSE COLON statements .)
    EXCEPT          reduce using rule 20 (if_stmt -> IF expr COLON statements ELSE COLON statements .)
    ELSE            reduce using rule 20 (if_stmt -> IF expr COLON statements ELSE COLON statements .)
    NEWLINE         shift and go to state 14
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19
    DEF             shift and go to state 20
    RETURN          shift and go to state 21
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    TRY             shift and go to state 24

  ! NEWLINE         [ reduce using rule 20 (if_stmt -> IF expr COLON statements ELSE COLON statements .) ]
  ! PRINT           [ reduce using rule 20 (if_stmt -> IF expr COLON statements ELSE COLON statements .) ]
  ! IDENTIFIER      [ reduce using rule 20 (if_stmt -> IF expr COLON statements ELSE COLON statements .) ]
  ! IF              [ reduce using rule 20 (if_stmt -> IF expr COLON statements ELSE COLON statements .) ]
  ! WHILE           [ reduce using rule 20 (if_stmt -> IF expr COLON statements ELSE COLON statements .) ]
  ! FOR             [ reduce using rule 20 (if_stmt -> IF expr COLON statements ELSE COLON statements .) ]
  ! DEF             [ reduce using rule 20 (if_stmt -> IF expr COLON statements ELSE COLON statements .) ]
  ! RETURN          [ reduce using rule 20 (if_stmt -> IF expr COLON statements ELSE COLON statements .) ]
  ! BREAK           [ reduce using rule 20 (if_stmt -> IF expr COLON statements ELSE COLON statements .) ]
  ! CONTINUE        [ reduce using rule 20 (if_stmt -> IF expr COLON statements ELSE COLON statements .) ]
  ! TRY             [ reduce using rule 20 (if_stmt -> IF expr COLON statements ELSE COLON statements .) ]

    statement                      shift and go to state 25
    print_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    if_stmt                        shift and go to state 6
    while_stmt                     shift and go to state 7
    for_stmt                       shift and go to state 8
    function_def                   shift and go to state 9
    return_stmt                    shift and go to state 10
    break_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    try_except_stmt                shift and go to state 13

state 140

    (23) function_def -> DEF IDENTIFIER LPAREN param_list RPAREN COLON statements .
    (3) statements -> statements . statement
    (4) statement -> . print_stmt
    (5) statement -> . assign_stmt
    (6) statement -> . if_stmt
    (7) statement -> . while_stmt
    (8) statement -> . for_stmt
    (9) statement -> . function_def
    (10) statement -> . return_stmt
    (11) statement -> . break_stmt
    (12) statement -> . continue_stmt
    (13) statement -> . try_except_stmt
    (14) statement -> . NEWLINE
    (15) print_stmt -> . PRINT LPAREN expr RPAREN
    (16) print_stmt -> . PRINT expr
    (17) assign_stmt -> . IDENTIFIER EQUALS expr
    (18) assign_stmt -> . IDENTIFIER LBRACKET expr RBRACKET EQUALS expr
    (19) if_stmt -> . IF expr COLON statements
    (20) if_stmt -> . IF expr COLON statements ELSE COLON statements
    (21) while_stmt -> . WHILE expr COLON statements
    (22) for_stmt -> . FOR IDENTIFIER IN expr COLON statements
    (23) function_def -> . DEF IDENTIFIER LPAREN param_list RPAREN COLON statements
    (27) return_stmt -> . RETURN expr
    (28) return_stmt -> . RETURN
    (29) break_stmt -> . BREAK
    (30) continue_stmt -> . CONTINUE
    (31) try_except_stmt -> . TRY COLON statements EXCEPT COLON statements

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
    $end            reduce using rule 23 (function_def -> DEF IDENTIFIER LPAREN param_list RPAREN COLON statements .)
    EXCEPT          reduce using rule 23 (function_def -> DEF IDENTIFIER LPAREN param_list RPAREN COLON statements .)
    ELSE            reduce using rule 23 (function_def -> DEF IDENTIFIER LPAREN param_list RPAREN COLON statements .)
    NEWLINE         shift and go to state 14
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 16
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19
    DEF             shift and go to state 20
    RETURN          shift and go to state 21
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 23
    TRY             shift and go to state 24

  ! NEWLINE         [ reduce using rule 23 (function_def -> DEF IDENTIFIER LPAREN param_list RPAREN COLON statements .) ]
  ! PRINT           [ reduce using rule 23 (function_def -> DEF IDENTIFIER LPAREN param_list RPAREN COLON statements .) ]
  ! IDENTIFIER      [ reduce using rule 23 (function_def -> DEF IDENTIFIER LPAREN param_list RPAREN COLON statements .) ]
  ! IF              [ reduce using rule 23 (function_def -> DEF IDENTIFIER LPAREN param_list RPAREN COLON statements .) ]
  ! WHILE           [ reduce using rule 23 (function_def -> DEF IDENTIFIER LPAREN param_list RPAREN COLON statements .) ]
  ! FOR             [ reduce using rule 23 (function_def -> DEF IDENTIFIER LPAREN param_list RPAREN COLON statements .) ]
  ! DEF             [ reduce using rule 23 (function_def -> DEF IDENTIFIER LPAREN param_list RPAREN COLON statements .) ]
  ! RETURN          [ reduce using rule 23 (function_def -> DEF IDENTIFIER LPAREN param_list RPAREN COLON statements .) ]
  ! BREAK           [ reduce using rule 23 (function_def -> DEF IDENTIFIER LPAREN param_list RPAREN COLON statements .) ]
  ! CONTINUE        [ reduce using rule 23 (function_def -> DEF IDENTIFIER LPAREN param_list RPAREN COLON statements .) ]
  ! TRY             [ reduce using rule 23 (function_def -> DEF IDENTIFIER LPAREN param_list RPAREN COLON statements .) ]

    statement                      shift and go to state 25
    print_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    if_stmt                        shift and go to state 6
    while_stmt                     shift and go to state 7
    for_stmt                       shift and go to state 8
    function_def                   shift and go to state 9
    return_stmt                    shift and go to state 10
    break_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    try_except_stmt                shift and go to state 13
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 21 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 71 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 77 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 110 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 110 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 110 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 110 resolved as shift
WARNING: shift/reduce conflict for IF in state 110 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 110 resolved as shift
WARNING: shift/reduce conflict for FOR in state 110 resolved as shift
WARNING: shift/reduce conflict for DEF in state 110 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 110 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 110 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 110 resolved as shift
WARNING: shift/reduce conflict for TRY in state 110 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 112 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 112 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 112 resolved as shift
WARNING: shift/reduce conflict for IF in state 112 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 112 resolved as shift
WARNING: shift/reduce conflict for FOR in state 112 resolved as shift
WARNING: shift/reduce conflict for DEF in state 112 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 112 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 112 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 112 resolved as shift
WARNING: shift/reduce conflict for TRY in state 112 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 120 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 134 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 134 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 134 resolved as shift
WARNING: shift/reduce conflict for IF in state 134 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 134 resolved as shift
WARNING: shift/reduce conflict for FOR in state 134 resolved as shift
WARNING: shift/reduce conflict for DEF in state 134 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 134 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 134 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 134 resolved as shift
WARNING: shift/reduce conflict for TRY in state 134 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 137 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 137 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 137 resolved as shift
WARNING: shift/reduce conflict for IF in state 137 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 137 resolved as shift
WARNING: shift/reduce conflict for FOR in state 137 resolved as shift
WARNING: shift/reduce conflict for DEF in state 137 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 137 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 137 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 137 resolved as shift
WARNING: shift/reduce conflict for TRY in state 137 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 139 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 139 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 139 resolved as shift
WARNING: shift/reduce conflict for IF in state 139 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 139 resolved as shift
WARNING: shift/reduce conflict for FOR in state 139 resolved as shift
WARNING: shift/reduce conflict for DEF in state 139 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 139 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 139 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 139 resolved as shift
WARNING: shift/reduce conflict for TRY in state 139 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 140 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 140 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 140 resolved as shift
WARNING: shift/reduce conflict for IF in state 140 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 140 resolved as shift
WARNING: shift/reduce conflict for FOR in state 140 resolved as shift
WARNING: shift/reduce conflict for DEF in state 140 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 140 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 140 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 140 resolved as shift
WARNING: shift/reduce conflict for TRY in state 140 resolved as shift
WARNING: reduce/reduce conflict in state 86 resolved using rule (print_stmt -> PRINT LPAREN expr RPAREN)
WARNING: rejected rule (factor -> LPAREN expr RPAREN) in state 86
